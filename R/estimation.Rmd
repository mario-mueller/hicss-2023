---
title: "RSiena Analysis"
author: "Mario Mueller"
date: "5/19/2022"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(tidygraph)
library(igraph)
library(network)
library(sna)
library(intergraph)
library(RSiena)
library(multiSiena)
library(patchwork)
library(texreg)
# setwd("/Users/mariomueller/Workspace/hicss-2023")
```

# Required Functions

```{r}
# Functions are adapted from tutorial for the Social Networks and Health 
#   workshop at Duke University on May 18, 2018 by David R. Schaefer

outTable <- function(x) {
  coef <- abs(x$theta)
  coefPretty <- sprintf("%.3f", round(coef,3))
  se <- diag(x$covtheta)**.5
  sePretty <- sprintf("%.3f", round(se,3))
  pval <- 2*pnorm(-abs(coef/se))
  symp <- symnum(pval, corr = FALSE,
                 cutpoints = c(0,  .001,.01,.05, .1, 1),
                 symbols = c("***","**","*","."," "))
  convPretty <- sprintf("%.3f", round(abs(x$tconv),3))
  out1 <- noquote(cbind(
    Function = x$effects[[1]], 
    Effect = x$effects[[2]], 
    Coef = coefPretty, 
    StEr = sePretty, 
    Sig = symp, 
    Conv = convPretty))
  out2 <- paste("Maximum Convergence Ratio:", round(x$tconv.max,3))
  return(list(out1,out2))
}
```

# Data Preparation

## Node Sets & Composition Changes

```{r}
# Load Node Lists
devs <- read_csv("./data/nodelists/developers.csv", col_names = TRUE)
pkgs <- read_csv("./data/nodelists/packages.csv", col_names = TRUE)

# Save numbers of developers and packages for network dimensions
num_devs <- dim(devs)[1]
num_pkgs <- dim(pkgs)[1]

# Node Sets
devs <- sienaNodeSet(num_devs, nodeSetName = "devs")
pkgs <- sienaNodeSet(num_pkgs, nodeSetName = "pkgs")

# Composition Changes for both Node Sets
comp <- sienaCompositionChangeFromFile('data/compositions/comp_change.txt', nodeSet = "devs")
```

## Networks

### Affiliation Network (Two-Mode)

```{r}
# Load adjacency matrices
net1 <- as.matrix(read.table('data/adjacency/net-2021-02-01.txt'))
net2 <- as.matrix(read.table('data/adjacency/net-2021-03-01.txt'))
net3 <- as.matrix(read.table('data/adjacency/net-2021-04-01.txt'))
net4 <- as.matrix(read.table('data/adjacency/net-2021-05-01.txt'))

# Create network object
netList <- list(net1, net2, net3, net4)
netArray <- array(c(net1, net2, net3, net4), dim=c(num_devs, num_pkgs, length(netList)))
net <- sienaDependent(netArray, type="bipartite", nodeSet = c("devs", "pkgs"))

# Check network dimensions
lapply(netList, dim)   # each network has the same number of actors as needed
lapply(netList, function(x) table(x, useNA='always'))
```

### Plot Network

```{r}
g.layout <- gplot(apply(netArray, c(1,2), max), usearrows=T)
par(mfrow=c(1,1))
gplot(netArray[,,4], gmode="twomode",
      arrowhead.cex=.75, edge.col='gray70', coord=g.layout, vertex.cex=1.5)
```

## Individual Variables

### Packages

```{r}
# Dependencies
deps_up     <- as.matrix(read.table('data/individual/pkg_upstream.txt'))
deps_down   <- as.matrix(read.table('data/individual/pkg_downstream.txt'))
depsUpVar   <- varCovar(deps_up, nodeSet = "pkgs")
depsDownVar <- varCovar(deps_down, nodeSet = "pkgs")

deps_up_log    <- log(deps_up + 1)
deps_down_log  <- log(deps_down + 1)
depsUpLogVar   <- varCovar(deps_up_log, nodeSet = "pkgs", centered = T) 
depsDownLogVar <- varCovar(deps_down_log, nodeSet = "pkgs", centered = T)
  
# Community Interest
com_int   <- as.matrix(read.table('data/individual/pkg_community.txt'))
comIntVar <- varCovar(com_int, nodeSet = "pkgs")

com_int_log  <- log(com_int + 1)
comIntLogVar <- varCovar(com_int_log, nodeSet = "pkgs", centered = T)

# Release Activity
releases  <- as.matrix(read.table('data/individual/pkg_releases.txt'))
relActVar <- varCovar(releases, nodeSet = "pkgs")

releases_log <- log(releases + 1)
relActLogVar <- varCovar(releases_log, nodeSet = "pkgs", centered = T)

# Repository Owner Type
# types <- as.matrix(read.table('data/individual/pkg_repo_types.txt'))
# typeVar <- coCovar(types[,1], nodeSet = "pkgs")

# Age
age    <- as.matrix(read.table('data/individual/pkg_age.txt'))
ageVar <- varCovar(age, nodeSet = "pkgs")

age_log <- log(age)
ageLogVar <- varCovar(age_log, nodeSet = "pkgs", centered = T)
```

### Developers

```{r}
dev_act   <- as.matrix(read.table('data/individual/dev_activity.txt'))
devActVar <- varCovar(dev_act, nodeSet = "devs")

dev_act_log <- log(dev_act + 1)
devActLogVar <- varCovar(dev_act_log, nodeSet = "devs", centered = T)
```

## Dyadic Variables

### Upstream Dependencies

```{r}
# Dependency Associations
depUp1 <- as.matrix(read.table('data/dyadic/dep_up_associations-2021-02-01.txt'))
depUp2 <- as.matrix(read.table('data/dyadic/dep_up_associations-2021-03-01.txt'))
depUp3 <- as.matrix(read.table('data/dyadic/dep_up_associations-2021-04-01.txt'))
# Last observation not required

# Create network object
depUpList  <- list(depUp1, depUp2, depUp3)
depUpArray <- array(c(depUp1, depUp2, depUp3),
                    dim=c(num_devs, num_pkgs, length(depUpList)))
depUpDyad  <- varDyadCovar(depUpArray, nodeSets = c("devs", "pkgs"), type = "bipartite")
```

### Downstream Dependencies

```{r}
# Dependency Associations
depDown1 <- as.matrix(read.table('data/dyadic/dep_down_associations-2021-02-01.txt'))
depDown2 <- as.matrix(read.table('data/dyadic/dep_down_associations-2021-03-01.txt'))
depDown3 <- as.matrix(read.table('data/dyadic/dep_down_associations-2021-04-01.txt'))

# Create network object
depDownList  <- list(depDown1, depDown2, depDown3)
depDownArray <- array(c(depDown1, depDown2, depDown3),
                    dim=c(num_devs, num_pkgs, length(depDownList)))
depDownDyad  <- varDyadCovar(depDownArray, nodeSets = c("devs", "pkgs"), type = "bipartite")
```

## Initialization

```{r}
data <- sienaDataCreate(net, comp,
                        devActLogVar, comIntLogVar, relActLogVar, ageLogVar,
                        depsUpLogVar, depsDownLogVar, depUpDyad, depDownDyad,
                        nodeSets = list(devs, pkgs))
saveRDS(data, "data/sienaData.rds")
data <- readRDS("data/sienaData.rds")
print01Report(data, modelname='hicss-2023-final')
```

# Model Estimations

## Initialize Algorithm

```{r}
algorithm <- sienaAlgorithmCreate(projname='hicss-2023-final',
                                  seed=17,
                                  n3=3000) # 1000 standard, 3000 for publication
effects <- getEffects(data, nintn = 50)
effectsDocumentation(effects)
```

## Model 1

In the first model, we add endogenous structural effects to the model. Initial
data analysis showed a skewed out-degree distribution. In this case, it is advised
to let the rate function depend on a covariate (Ripley et al. 2022); in our case
developer activity. Furthermore, we add an effect for the in-degree popularity
of a package.

```{r}
effects1 <- effects
effects1 <- setEffect(effects1, RateX, name="net", type="rate",
                      interaction1="devActLogVar",
                      fix=T, test=T, include=T)
effects1 <- setEffect(effects1, inPopSqrt,
                      fix=T, test=T, include=T)

model1.stt <- siena07(algorithm, data=data, effects=effects1,
                      batch=F, verbose=F, returnDeps=T, initC=T, useCluster=T,
                      byWave=T, nbrNodes=12)
summary(model1.stt)
```

The score-test for (1) the effect of developer activity on the rate function
(chi-square = 43.5490, p < 0.001) and (2) the in-degree popularity effect
(squared) (chi-square = 214.0247, p < 0.0001) indicates that both effects should
be included in the model.

```{r}
effects1 <- effects
effects1 <- setEffect(effects1, RateX, name="net", type="rate", interaction1="devActLogVar",
                      fix=F, test=F, include=T)
effects1 <- setEffect(effects1, inPopSqrt,
                      fix=F, test=F, include=T)

model1 <- siena07(algorithm, data=data, effects=effects1,
                  batch=F, verbose=F, returnDeps=T, initC=T, useCluster=T,
                  byWave=T, nbrNodes=12)
summary(model1)

# Wald-type test
wald1 <- Multipar.RSiena(model1, c(4:model1$pp))

siena.table(model1, sig=T, type="html", file="tables/results_model1_final.html")
saveRDS(model1, "models/model1_final.rds")
```

Maximum convergence is < 0.08 and all t-ratios < |0.1|. There is also no critical
correlation between parameter estimates. The highest correlation is between
out-degree (density) and in-degree popularity (-0.874). The Wald-type test for
joint significance of the three effects shows that the affiliation network
depends on these effects (chi-squared = 2390.72, d.f. = 3;  p < 0.001).

Now, we test the goodness-of-fit for the in- and out-degree distribution.

```{r}
gof.id1 <- sienaGOF(model1, varName="net", IndegreeDistribution,
                    join=T, cumulative=F, verbose=T)
plot(gof.id1)

gof.od1 <- sienaGOF(model1, varName="net", OutdegreeDistribution,
                    join=T, cumulative=F, verbose=T)
plot(gof.od1)
```

In-degree distribution looks good already (p: 0.094). However, the model does not
fit the out-degree distribution yet (p: 0).

## Model 2

In the second model, we add the control effects for actor-specific covariates.
For packages, we include the effect of community interest, release activity,
and age. For developers, we include developer activity.

First, we test these effects with the score-type test.

```{r}
effects2 <- effects1
effects2 <- setEffect(effects2, egoX, name="net", interaction1="devActLogVar",
                      fix=T, test=T, include=T)
effects2 <- setEffect(effects2, altX, name="net", interaction1="comIntLogVar",
                      fix=T, test=T, include=T)
effects2 <- setEffect(effects2, altX, name="net", interaction1="relActLogVar",
                      fix=T, test=T, include=T)
effects2 <- setEffect(effects2, altX, name="net", interaction1="ageLogVar",
                      fix=T, test=T, include=T)

model2.stt <- siena07(algorithm, data=data, effects=effects2,
                      batch=F, verbose=F, returnDeps=T, initC=T, useCluster=T,
                      byWave=T, nbrNodes=12)
summary(model2.stt)
```

Besides developer activity (chi-squared = 220.7933, p-value < 0.0001), the package-
related effects are not significant according to the score-type test (p > 0.03).

Therefore, we test the variables of interest now.

```{r}
effects2 <- effects1

effects2 <- setEffect(effects2, altX, name="net", interaction1="depsUpLogVar",
                      fix=T, test=T, include=T)
effects2 <- setEffect(effects2, altX, name="net", interaction1="depsDownLogVar",
                      fix=T, test=T, include=T)
effects2 <- setEffect(effects2, X, name="net", interaction1="depUpDyad",
                      fix=T, test=T, include=T)
effects2 <- setEffect(effects2, X, name="net", interaction1="depDownDyad",
                      fix=T, test=T, include=T)

model2.stt <- siena07(algorithm, data=data, effects=effects2,
                      batch=F, verbose=F, returnDeps=T, initC=T, useCluster=T,
                      byWave=T, nbrNodes=12)
summary(model2.stt)
```

The score-type test shows, that the dyadic covariates are highly significant,
whereas the number of up- and downstream is not. Hence, we include both dyadic 
effects in the model.

```{r}
effects2 <- effects1

effects2 <- setEffect(effects2, X, name="net", interaction1="depUpDyad",
                      fix=F, test=F, include=T)
effects2 <- setEffect(effects2, X, name="net", interaction1="depDownDyad",
                      fix=F, test=F, include=T)

model2 <- siena07(algorithm, data=data, effects=effects2,
                  batch=F, verbose=F, returnDeps=T, initC=T, useCluster=T,
                  byWave=T, nbrNodes=12)
summary(model2)

# Wald-type test
wald2 <- Multipar.RSiena(model2, c(4:model2$pp))

siena.table(model2, sig=T, type="html", file="tables/results_model2_final.html")
saveRDS(model2, "models/model2_final.rds")
```

Maximum convergence ratio is good (0.08) and all convergence t-ratios < 0.06.
Wald-type statistics decrease a little (chi-squared = 2305.23, d.f. = 5;  p < 0.001).
Correlations between estimates basically unchanged.

```{r}
gof.id2 <- sienaGOF(model2, varName="net", IndegreeDistribution,
                    join=T, cumulative=F, verbose=T)
plot(gof.id2)

gof.od2 <- sienaGOF(model2, varName="net", OutdegreeDistribution,
                    join=T, cumulative=F, verbose=T)
plot(gof.od2)
```

In-degree distribution improves from p = 0.094 to p = 0.169.
Out-degree distribution still bad... (p = 0)

## Model 3

We test various structural effects next.

```{r}
effects3 <- effects2

effects3 <- setEffect(effects3, cycle4, fix=T, test=T, include=T)
effects3 <- setEffect(effects3, outActSqrt, fix=T, test=T, include=T)
effects3 <- setEffect(effects3, outTrunc, parameter=2, fix=T, test=T, include=T)
effects3 <- setEffect(effects3, outInAss, parameter=2, fix=T, test=T, include=T)

effects3 <- setEffect(effects3, antiInIso, fix=F, test=F, include=F)
effects3 <- setEffect(effects3, antiInIso2, fix=F, test=F, include=F)

model3.stt <- siena07(algorithm, data=data, effects=effects3,
                      batch=F, verbose=F, returnDeps=T, initC=T, useCluster=T,
                      byWave=T, nbrNodes=12)
summary(model3.stt)
```

Results from the score-type test incidcate that 4-cycles is highly significant
(chi-squared = 94.5300, p < 0.0001). So is out-degree activity and out-degree
truncated.

Initial analysis showed that density highly correlates with outTrunc and outActSqrt.
Hence, we exclude them for now.

```{r}
effects3 <- effects2

effects3 <- setEffect(effects3, cycle4, fix=F, test=F, include=T)

model3 <- siena07(algorithm, data=data, effects=effects3,
                  batch=F, verbose=F, returnDeps=T, initC=T, useCluster=T,
                  byWave=T, nbrNodes=12)
summary(model3)

# Wald-type test
wald3 <- Multipar.RSiena(model3, c(4:model3$pp))

siena.table(model3, sig=T, type="html", file="tables/results_model3_final.html")
saveRDS(model3, "models/model3_final.rds")
```

Maximum convergence ratio is better (0.074) and all convergence t-ratios < 0.05.
Wald-type statistics improves (chi-squared = 2476.59, d.f. = 6;  p < 0.001).
Correlations between estimates basically unchanged.

```{r}
gof.id3 <- sienaGOF(model3, varName="net", IndegreeDistribution,
                    join=T, cumulative=F, verbose=T)
plot(gof.id3)

gof.od3 <- sienaGOF(model3, varName="net", OutdegreeDistribution,
                    join=T, cumulative=F, verbose=T)
plot(gof.od3)
```

In-degree distribution improves from p = 0.169 to p = 0.179.
Out-degree distribution still bad... (p = 0)

## Model 4

Let's test control variables again. Add developer activity first, since this
has been shown to be significant before.

```{r}
effects4 <- effects3

effects4 <- setEffect(effects4, egoX, name="net", interaction1="devActLogVar",
                      fix=T, test=T, include=T)

model4.stt <- siena07(algorithm, data=data, effects=effects4,
                      batch=F, verbose=F, returnDeps=T, initC=T, useCluster=T,
                      byWave=T, nbrNodes=12)
summary(model4.stt)
```

Still super significant. Add in the next step.

```{r}
effects4 <- effects3

effects4 <- setEffect(effects4, egoX, name="net", interaction1="devActLogVar",
                      fix=F, test=F, include=T)

model4 <- siena07(algorithm, data=data, effects=effects4,
                  batch=F, verbose=F, returnDeps=T, initC=T, useCluster=T,
                  byWave=T, nbrNodes=12)
summary(model4)

# Wald-type test
wald4 <- Multipar.RSiena(model4, c(4:model4$pp))

siena.table(model4, sig=T, type="html", file="tables/results_model4_final.html")
saveRDS(model4, "models/model4_final.rds")
```

Maximum convergence ratio 0.08 and all convergence t-ratios < 0.06.
Wald-type statistics improves drastically (chi-squared = 3757.83, d.f. = 7;  p < 0.001)
Correlations between estimates also improves.

```{r}
gof.id4 <- sienaGOF(model4, varName="net", IndegreeDistribution,
                    join=T, cumulative=F, verbose=T)
plot(gof.id4)

gof.od4 <- sienaGOF(model4, varName="net", OutdegreeDistribution,
                    join=T, cumulative=F, verbose=T)
plot(gof.od4)
```

In-degree distribution slightly worse from p = 0.179 to p = 0.141.
Out-degree distribution better p = 0.013, but still not quite there yet.

# Results

```{r}
gof.string1 <- sprintf("%.2f (%d)", wald1$chisquare, wald1$df)
gof.string2 <- sprintf("%.2f (%d)", wald2$chisquare, wald2$df)
gof.string3 <- sprintf("%.2f (%d)", wald3$chisquare, wald3$df)
gof.string4 <- sprintf("%.2f (%d)", wald4$chisquare, wald4$df)

texreg::htmlreg(list(model1, model2, model3, model4),
                stars = c(0.1, 0.05, 0.01, 0.001),
                single.row = TRUE, include.iterations = FALSE,
                custom.gof.rows = list(
                  "Wald Statistics" = c(
                    gof.string1, gof.string2, gof.string3, gof.string4)),
                file = 'tables/results_final.html')
```

---

# Previous Estimations

## Model 1: Endogenous

```{r}
effects <- getEffects(data, nintn = 50)

effects <- setEffect(effects, inPopSqrt, fix=F, test=F, include=T)
effects <- setEffect(effects, outTrunc, parameter=2, fix=F, test=F, include=T)
effects <- setEffect(effects, outIso, fix=F, test=F, include=T)
effects <- setEffect(effects, antiInIso, fix=F, test=F, include=T)
effects <- setEffect(effects, in2Plus, fix=F, test=F, include=T)
effects <- setEffect(effects, in3Plus, fix=F, test=F, include=T)

model1 <- siena07(algorithm, data=data, effects=effects,
                  batch=F, verbose=F, returnDeps=T, initC=T, useCluster=T,
                  byWave=T, nbrNodes=12)
saveRDS(model1, "models/model1.rds")
siena.table(model1, type="html", file="tables/results_model1.html",
            sig=T)
```


## Model 2: Controls

```{r}
effects <- setEffect(effects, egoX, name="net", interaction1="devActLogVar",
                     fix=F, test=F, include=T)
effects <- setEffect(effects, altX, name="net", interaction1="comIntLogVar",
                     fix=F, test=F, include=T)
effects <- setEffect(effects, altX, name="net", interaction1="relActLogVar",
                     fix=F, test=F, include=T)
effects <- setEffect(effects, altX, name="net", interaction1="ageLogVar",
                     fix=F, test=F, include=T)

model2 <- siena07(algorithm, data=data, effects=effects,
                  batch=F, verbose=F, returnDeps=T, initC=T, useCluster=T,
                  byWave=T, nbrNodes=12)
saveRDS(model2, "models/model2.rds")

siena.table(model2, type="html", file="tables/results_model2.html",
            sig=T)
```


## Model 3: Full

```{r}
effects <- setEffect(effects, altX, name="net", interaction1="depsUpLogVar",
                     fix=F, test=F, include=T)
effects <- setEffect(effects, altX, name="net", interaction1="depsDownLogVar",
                     fix=F, test=F, include=T)
effects <- setEffect(effects, X, name="net", interaction1="depUpDyad",
                     fix=F, test=F, include=T)
effects <- setEffect(effects, X, name="net", interaction1="depDownDyad",
                     fix=F, test=F, include=T)

model3 <- siena07(algorithm, data=data, effects=effects,
                  batch=F, verbose=F, returnDeps=T, initC=T, useCluster=T,
                  byWave=T, nbrNodes=12)
saveRDS(model3, "models/model3.rds")
siena.table(model3, type="html", file="tables/results_model3.html",
            sig=T)

```

## Results Table

```{r}
wald1 <- Multipar.RSiena(model1, c(1:model1$pp))
wald2 <- Multipar.RSiena(model2, c(1:model2$pp))
wald3 <- Multipar.RSiena(model3, c(1:model3$pp))

gof.string1 <- sprintf("%.2f (%d)", wald1$chisquare, wald1$df)
gof.string2 <- sprintf("%.2f (%d)", wald2$chisquare, wald2$df)
gof.string3 <- sprintf("%.2f (%d)", wald3$chisquare, wald3$df)

texreg::htmlreg(list(model1, model2, model3),
                stars = c(0.1, 0.05, 0.01, 0.001),
                single.row = TRUE, include.iterations = FALSE,
                custom.gof.rows = list(
                  "Wald Statistics" = c(gof.string1, gof.string2, gof.string3)),
                file = 'tables/results.html')
```

## Goodness of Fit

```{r}
gof.id.full <- sienaGOF(model3, verbose=TRUE, varName="net",
                        IndegreeDistribution, join=T, cumulative=F)
plot(gof.id.full)

gof.od.full <- sienaGOF(model3, verbose=TRUE, varName="net",
                        OutdegreeDistribution, join=T, cumulative=F)
plot(gof.od.full)
```

## Model 4: Additional Tests

```{r}
effects.fix <- effects

# Leads to high maximum convergence > 6
# effects.fix <- setEffect(effects.fix, outRate, name="net", type="rate",
#                         fix=F, test=F, include=F)
# This should be included!
effects.fix <- setEffect(effects.fix, RateX, name="net", type="rate",
                         interaction1="devActLogVar", fix=F, test=F, include=T)
# No realy improvement here, Wald statistics worse
# effects.fix <- setEffect(effects.fix, outAct, fix=F, test=F, include=F)

effects.fix <- setEffect(effects.fix, inPopSqrt, fix=F, test=F, include=T)
effects.fix <- setEffect(effects.fix, outTrunc, parameter=2, fix=F, test=F, include=T)
effects.fix <- setEffect(effects.fix, outIso, fix=F, test=F, include=F)
effects.fix <- setEffect(effects.fix, antiInIso, fix=F, test=F, include=F)
effects.fix <- setEffect(effects.fix, in2Plus, fix=F, test=F, include=F)
effects.fix <- setEffect(effects.fix, in3Plus, fix=F, test=F, include=T)

model4 <- siena07(algorithm, data=data, effects=effects.fix,
                  batch=F, verbose=F, returnDeps=T, initC=T, useCluster=T,
                  byWave=T, nbrNodes=12)

outTable(model4)

wald4 <- Multipar.RSiena(model4, c(1:model4$pp))
gof.string4 <- sprintf("%.2f (%d)", wald4$chisquare, wald4$df)

texreg::htmlreg(list(model1, model2, model3, model4),
                stars = c(0.1, 0.05, 0.01, 0.001),
                single.row = TRUE, include.iterations = FALSE,
                custom.gof.rows = list(
                  "Wald Statistics" = c(gof.string1, gof.string2, gof.string3, gof.string4)),
                file = 'tables/results.html')

gof.id.fix <- sienaGOF(model4, verbose=TRUE, varName="net",
                        IndegreeDistribution, join=T, cumulative=F)
plot(gof.id.fix)

gof.od.fix <- sienaGOF(model4, verbose=TRUE, varName="net",
                        OutdegreeDistribution, join=T, cumulative=F)
plot(gof.od.fix)
```

## Model 5: More Tests

```{r}
# Leads to high maximum convergence > 6
effects.fix <- setEffect(effects.fix, outTrunc, parameter=2, fix=F, test=F, include=F)

model5 <- siena07(algorithm, data=data, effects=effects.fix,
                  batch=F, verbose=F, returnDeps=T, initC=T, useCluster=T,
                  byWave=T, nbrNodes=12)

outTable(model5)

wald5 <- Multipar.RSiena(model5, c(1:model5$pp))
gof.string5 <- sprintf("%.2f (%d)", wald5$chisquare, wald5$df)

texreg::htmlreg(list(model1, model2, model3, model4, model5),
                stars = c(0.1, 0.05, 0.01, 0.001),
                single.row = TRUE, include.iterations = FALSE,
                custom.gof.rows = list(
                  "Wald Statistics" = c(
                    gof.string1, gof.string2, gof.string3, gof.string4, gof.string5)),
                file = 'tables/results.html')

gof.id.fix2 <- sienaGOF(model5, verbose=TRUE, varName="net",
                        IndegreeDistribution, join=T, cumulative=F)
plot(gof.id.fix2)

gof.od.fix2 <- sienaGOF(model5, verbose=TRUE, varName="net",
                        OutdegreeDistribution, join=T, cumulative=F)
plot(gof.od.fix2)
```

# ARCHIVE: Model Forward-Selection

## Model 1

```{r}
effects1 <- effects

ans.model1 <- siena07(algorithm, data=data, effects=effects1,
                      batch=F, verbose=F, returnDeps=T, initC=T, useCluster=T,
                      byWave=T, nbrNodes=12)
outTable(ans.model1)
Multipar.RSiena(ans.model1, ans.model1$pp)  # c = 10276.73, d.f. = 1; two-sided p < 0.001.
```

```{r}
# GOF
gof.id1 <- sienaGOF(ans.model1, verbose=TRUE, varName="net",
                   IndegreeDistribution, join=T, cumulative=F)
plot(gof.id1)

gof.od1 <- sienaGOF(ans.model1, verbose=TRUE, varName="net",
                    OutdegreeDistribution, join=T, cumulative=F)
plot(gof.od1)
```

## Model 2

In this model, important structural effects for two-mode networks are tested and
estimated.

- Transitivity-related Effects: Four-Cycles (Robins and Alexander, 2004)
  - Reflects the extent to which actors who make on choice in common also make
    other choices in common.
- Degree-related Effects:
  - Out-degree activity: Tendencies of dispersion in out-degrees of actors
  - In-degree popularity: Tendencies of dispersion in in-degree of column units
  - Out-in degree assortativity effect (param 2 = sqrt, param 1 = non-sqrt): 
    Tendencies for actors with high out-degrees to preferably be tied to column
    units with high in-degrees

```{r}
effects2 <- effects1

effects2 <- setEffect(effects2, cycle4, fix=T, test=T, include=T)
effects2 <- setEffect(effects2, inPop, fix=T, test=T, include=T)
effects2 <- setEffect(effects2, outAct, fix=T, test=T, include=T)
effects2 <- setEffect(effects2, outTrunc, parameter=2, fix=T, test=T, include=T)
effects2 <- setEffect(effects2, outTrunc2, parameter=3, fix=T, test=T, include=T)
effects2 <- setEffect(effects2, antiInIso, fix=T, test=T, include=T)
effects2 <- setEffect(effects2, antiInIso2, fix=T, test=T, include=T)
effects2 <- setEffect(effects2, outInAss, parameter=1, fix=T, test=T, include=T)

ans.model2.stt <- siena07(algorithm, data=data, effects=effects2,
                          batch=F, verbose=F, returnDeps=T, initC=T, useCluster=T,
                          byWave=T, nbrNodes=12)
summary(ans.model2.stt)
```

```{r}
effects2 <- effects1

effects2 <- setEffect(effects2, cycle4, fix=F, test=F, include=T)
# effects2 <- setEffect(effects2, inPop, fix=F, test=F, include=T)
effects2 <- setEffect(effects2, outAct, fix=F, test=F, include=T)
# outAct removed
# effects2 <- setEffect(effects2, outTrunc, parameter=2, fix=F, test=F, include=T)
# effects2 <- setEffect(effects2, outTrunc2, parameter=3, fix=F, test=F, include=T)
effects2 <- setEffect(effects2, antiInIso, fix=F, test=F, include=T)
effects2 <- setEffect(effects2, antiInIso2, fix=F, test=F, include=T)
effects2 <- setEffect(effects2, outInAss, parameter=1, fix=F, test=F, include=T)
# Correlates strongly with inPop

ans.model2a <- siena07(algorithm, data=data, effects=effects2,
                       batch=F, verbose=F, returnDeps=T, initC=T, useCluster=T,
                       byWave=T, nbrNodes=12)

outTable(ans.model2a)
Multipar.RSiena(ans.model2a, c(1:ans.model2a$pp))
```

```{r}
effects2 <- effects1

effects2 <- setEffect(effects2, cycle4, fix=F, test=F, include=T)
effects2 <- setEffect(effects2, inPop, fix=F, test=F, include=T)
effects2 <- setEffect(effects2, outAct, fix=F, test=F, include=T)
# outAct removed
# effects2 <- setEffect(effects2, outTrunc, parameter=2, fix=F, test=F, include=T)
# effects2 <- setEffect(effects2, outTrunc2, parameter=3, fix=F, test=F, include=T)
effects2 <- setEffect(effects2, antiInIso, fix=F, test=F, include=T)
effects2 <- setEffect(effects2, antiInIso2, fix=F, test=F, include=T)
# effects2 <- setEffect(effects2, outInAss, parameter=1, fix=F, test=F, include=T)
# Correlates strongly with inPop

ans.model2b <- siena07(algorithm, data=data, effects=effects2,
                       batch=F, verbose=F, returnDeps=T, initC=T, useCluster=T,
                       byWave=T, nbrNodes=12)

outTable(ans.model2b)
Multipar.RSiena(ans.model2b, c(1:ans.model2b$pp))
```


```{r}
# GOF
gof.id2b <- sienaGOF(ans.model2b, verbose=TRUE, varName="net",
                     IndegreeDistribution, join=T, cumulative=F)
plot(gof.id2b)

gof.od2b <- sienaGOF(ans.model2b, verbose=TRUE, varName="net",
                     OutdegreeDistribution, join=T, cumulative=F)
plot(gof.od2b)
```

## Model 3

```{r}
effects3 <- effects2

effects3 <- setEffect(effects3, egoX, name="net", interaction1="devActLogVar",
                      include=T, test=T, fix=T)
effects3 <- setEffect(effects3, altX, name="net", interaction1="comIntLogVar",
                      include=T, test=T, fix=T)
effects3 <- setEffect(effects3, altX, name="net", interaction1="relActLogVar",
                      include=T, test=T, fix=T)
effects3 <- setEffect(effects3, altSqX, name="net", interaction1="ageLogVar",
                      include=T, test=T, fix=T)

ans.model3.stt <- siena07(algorithm, data=data, effects=effects3,
                          batch=F, verbose=F, returnDeps=T, initC=T, useCluster=T,
                          byWave=T, nbrNodes=12)
summary(ans.model3.stt)
```

```{r}
effects3 <- effects2

effects3 <- setEffect(effects3, egoX, name="net", interaction1="devActLogVar",
                      include=T, test=F, fix=F)
effects3 <- setEffect(effects3, altX, name="net", interaction1="comIntLogVar",
                      include=T, test=F, fix=F)
effects3 <- setEffect(effects3, altX, name="net", interaction1="relActLogVar",
                      include=T, test=F, fix=F)
effects3 <- setEffect(effects3, altX, name="net", interaction1="ageLogVar",
                      include=T, test=F, fix=F)

ans.model3 <- siena07(algorithm, data=data, effects=effects3,
                      batch=F, verbose=F, returnDeps=T, initC=T, useCluster=T,
                      byWave=T, nbrNodes=12)

outTable(ans.model3)
Multipar.RSiena(ans.model3, c(1:ans.model3$pp))
```

```{r}
# GOF
gof.id3 <- sienaGOF(ans.model3, verbose=TRUE, varName="net",
                   IndegreeDistribution, join=T, cumulative=F)
plot(gof.id3)

gof.od3 <- sienaGOF(ans.model3, verbose=TRUE, varName="net",
                    OutdegreeDistribution, join=T, cumulative=F)
plot(gof.od3)
```

## Model 4

```{r}
effects4 <- effects3

effects4 <- setEffect(effects4, altX, name="net", interaction1="depsUpLogVar",
                      include=T, test=T, fix=T)
effects4 <- setEffect(effects4, altX, name="net", interaction1="depsDownLogVar",
                      include=T, test=T, fix=T)

ans.model4.stt <- siena07(algorithm, data=data, effects=effects4,
                          batch=F, verbose=F, returnDeps=T, initC=T, useCluster=T,
                          byWave=T, nbrNodes=12)
summary(ans.model4.stt)
```

```{r}
effects4 <- effects3

effects4 <- setEffect(effects4, altX, name="net", interaction1="depsUpLogVar",
                      include=T, test=F, fix=F)
effects4 <- setEffect(effects4, altX, name="net", interaction1="depsDownLogVar",
                      include=T, test=F, fix=F)

ans.model4 <- siena07(algorithm, data=data, effects=effects4,
                      batch=F, verbose=F, returnDeps=T, initC=T, useCluster=T,
                      byWave=T, nbrNodes=12)

outTable(ans.model4)
Multipar.RSiena(ans.model4, c(1:ans.model4$pp))
```

```{r}
# GOF
gof.id4 <- sienaGOF(ans.model4, verbose=TRUE, varName="net",
                   IndegreeDistribution, join=T, cumulative=F)
plot(gof.id4)

gof.od4 <- sienaGOF(ans.model4, verbose=TRUE, varName="net",
                    OutdegreeDistribution, join=T, cumulative=F)
plot(gof.od4)
```

## Model 5

Add dyadic effects

```{r}
effects5 <- effects4

effects5 <- setEffect(effects5, X, name="net", interaction1="depUpDyad",
                      include=T, test=T, fix=T)
effects5 <- setEffect(effects5, X, name="net", interaction1="depDownDyad",
                      include=T, test=T, fix=T)

ans.model5.stt <- siena07(algorithm, data=data, effects=effects5,
                          batch=F, verbose=F, returnDeps=T, initC=T, useCluster=T,
                          byWave=T, nbrNodes=12)
summary(ans.model5.stt)
```

```{r}
effects5 <- effects4

effects5 <- setEffect(effects5, X, name="net", interaction1="depUpDyad",
                      include=T, test=F, fix=F)
effects5 <- setEffect(effects5, X, name="net", interaction1="depDownDyad",
                      include=T, test=F, fix=F)

ans.model5 <- siena07(algorithm, data=data, effects=effects5,
                      batch=F, verbose=F, returnDeps=T, initC=T, useCluster=T,
                      byWave=T, nbrNodes=12)

outTable(ans.model5)
Multipar.RSiena(ans.model5, c(1:ans.model5$pp))
```

```{r}
# GOF
gof.id5 <- sienaGOF(ans.model5, verbose=TRUE, varName="net",
                   IndegreeDistribution, join=T, cumulative=F)
plot(gof.id5)

gof.od5 <- sienaGOF(ans.model5, verbose=TRUE, varName="net",
                    OutdegreeDistribution, join=T, cumulative=F)
plot(gof.od5)
```

## Model 6

```{r}
effects6 <- effects5

effects6 <- setEffect(effects6, outRateLog, name="net", type="rate",
                      include=T, test=F, fix=F)

ans.model6 <- siena07(algorithm, data=data, effects=effects6,
                      batch=F, verbose=F, returnDeps=T, initC=T, useCluster=T,
                      byWave=T, nbrNodes=12)

outTable(ans.model6)
Multipar.RSiena(ans.model6, c(1:ans.model6$pp))
```

```{r}
# GOF
gof.id6 <- sienaGOF(ans.model6, verbose=TRUE, varName="net",
                   IndegreeDistribution, join=T, cumulative=F)
plot(gof.id6)

gof.od6 <- sienaGOF(ans.model6, verbose=TRUE, varName="net",
                    OutdegreeDistribution, join=T, cumulative=F)
plot(gof.od6)
```

# ARCHIVE: Model Backward-Selection

## Model 7

```{r}
effects7 <- effects6

effects7 <- setEffect(effects7, outAct, fix=F, test=F, include=F)

ans.model7 <- siena07(algorithm, data=data, effects=effects7,
                      batch=F, verbose=F, returnDeps=T, initC=T, useCluster=T,
                      byWave=T, nbrNodes=12)

outTable(ans.model7)
Multipar.RSiena(ans.model7, c(1:ans.model7$pp))

gof.id7 <- sienaGOF(ans.model7, verbose=TRUE, varName="net",
                   IndegreeDistribution, join=T, cumulative=F)
plot(gof.id7)

gof.od7 <- sienaGOF(ans.model7, verbose=TRUE, varName="net",
                    OutdegreeDistribution, join=T, cumulative=F)
plot(gof.od7)
```

## Model 8

```{r}
effects8 <- effects7

effects8 <- setEffect(effects8, inPop, fix=F, test=F, include=F)
effects8 <- setEffect(effects8, inPopSqrt, fix=F, test=F, include=T)

effects8 <- setEffect(effects8, cycle4, fix=F, test=F, include=F)
# effects8 <- setEffect(effects8, antiInIso, fix=F, test=F, include=F)
effects8 <- setEffect(effects8, antiInIso2, fix=F, test=F, include=F)

# effects8 <- setEffect(effects8, outRateLog, name="net", type="rate",
#                       include=F, test=F, fix=F)

ans.model8 <- siena07(algorithm, data=data, effects=effects8,
                      batch=F, verbose=F, returnDeps=T, initC=T, useCluster=T,
                      byWave=T, nbrNodes=12)

outTable(ans.model8)
Multipar.RSiena(ans.model8, c(1:ans.model8$pp))

gof.id8 <- sienaGOF(ans.model8, verbose=TRUE, varName="net",
                    IndegreeDistribution, join=T, cumulative=F)
plot(gof.id8)

gof.od8 <- sienaGOF(ans.model8, verbose=TRUE, varName="net",
                    OutdegreeDistribution, join=T, cumulative=F)
plot(gof.od8)
```

Best Model Yet:

[[1]]
      Function Effect                             Coef  StEr  Sig Conv 
 [1,] net      effect ln(outdegree+1) on rate net 0.207 0.208     0.047
 [2,] net      outdegree (density)                5.245 0.110 *** 0.012
 [3,] net      indegree - popularity (sqrt)       0.361 0.025 *** 0.002
 [4,] net      anti in-isolates                   0.567 0.153 *** 0.030
 [5,] net      depUpDyad                          1.906 0.492 *** 0.049
 [6,] net      depDownDyad                        1.637 0.400 *** 0.039
 [7,] net      devActLogVar ego                   0.214 0.026 *** 0.005
 [8,] net      depsUpLogVar alter                 0.085 0.025 *** 0.017
 [9,] net      depsDownLogVar alter               0.007 0.033     0.008
[10,] net      comIntLogVar alter                 0.213 0.028 *** 0.005
[11,] net      relActLogVar alter                 0.068 0.044     0.024
[12,] net      ageLogVar alter                    0.100 0.050 *   0.006

[[2]]
[1] "Maximum Convergence Ratio: 0.088"

Indegree Distribution: p: 0.029

## Model 9

```{r}
effects9 <- effects8

# With both indegree effects > p 0.118
effects9 <- setEffect(effects9, in2Plus, fix=F, test=F, include=T)
effects9 <- setEffect(effects9, in3Plus, fix=F, test=F, include=T)

ans.model9 <- siena07(algorithm, data=data, effects=effects9,
                      batch=F, verbose=F, returnDeps=T, initC=T, useCluster=T,
                      byWave=T, nbrNodes=12)

outTable(ans.model9)
Multipar.RSiena(ans.model9, c(1:ans.model9$pp))

gof.id9 <- sienaGOF(ans.model9, verbose=TRUE, varName="net",
                    IndegreeDistribution, join=T, cumulative=F)
plot(gof.id9)

gof.od9 <- sienaGOF(ans.model9, verbose=TRUE, varName="net",
                    OutdegreeDistribution, join=T, cumulative=F)
plot(gof.od9)
```

## Model 10

```{r}
effects10 <- effects9

effects10 <- setEffect(effects10, outRateLog, name="net", type="rate",
                       include=F, test=F, fix=F)

# This effect is nice! Improves GOF for Indegree and significant
effects10 <- setEffect(effects10, outIso, fix=F, test=F, include=T)
effects10 <- setEffect(effects10, outTrunc, parameter=2, fix=F, test=F, include=T)
# CONTINUE TODO Add outTrunc with varying parameter to improve GOF OD
# effects10 <- setEffect(effects10, outMore, fix=F, test=F, include=T)

ans.model10 <- siena07(algorithm, data=data, effects=effects10,
                       batch=F, verbose=F, returnDeps=T, initC=T, useCluster=T,
                       byWave=T, nbrNodes=12)

outTable(ans.model10)
Multipar.RSiena(ans.model10, c(1:ans.model10$pp))

gof.id10 <- sienaGOF(ans.model10, verbose=TRUE, varName="net",
                     IndegreeDistribution, join=T, cumulative=F)
plot(gof.id10)

gof.od10 <- sienaGOF(ans.model10, verbose=TRUE, varName="net",
                     OutdegreeDistribution, join=T, cumulative=F)
plot(gof.od10)
```
