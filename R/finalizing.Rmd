---
title: "RSiena Analysis"
author: "Mario Mueller"
date: "5/19/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(tidygraph)
library(igraph)
library(network)
library(sna)
library(intergraph)
library(RSiena)
library(multiSiena)
library(patchwork)
library(texreg)
# setwd("/Users/mariomueller/Workspace/hicss-2023")
```

# Required Functions

```{r}
# Functions are adapted from tutorial for the Social Networks and Health 
#   workshop at Duke University on May 18, 2018 by David R. Schaefer

outTable <- function(x) {
  coef <- abs(x$theta)
  coefPretty <- sprintf("%.3f", round(coef,3))
  se <- diag(x$covtheta)**.5
  sePretty <- sprintf("%.3f", round(se,3))
  pval <- 2*pnorm(-abs(coef/se))
  symp <- symnum(pval, corr = FALSE,
                 cutpoints = c(0,  .001,.01,.05, .1, 1),
                 symbols = c("***","**","*","."," "))
  convPretty <- sprintf("%.3f", round(abs(x$tconv),3))
  out1 <- noquote(cbind(
    Function = x$effects[[1]], 
    Effect = x$effects[[2]], 
    Coef = coefPretty, 
    StEr = sePretty, 
    Sig = symp, 
    Conv = convPretty))
  out2 <- paste("Maximum Convergence Ratio:", round(x$tconv.max,3))
  return(list(out1,out2))
}
```

# Data Preparation

## Node Sets & Composition Changes

```{r}
# Load Node Lists
devs <- read_csv("./data/nodelists/developers.csv", col_names = TRUE)
pkgs <- read_csv("./data/nodelists/packages.csv", col_names = TRUE)

# Save numbers of developers and packages for network dimensions
num_devs <- dim(devs)[1]
num_pkgs <- dim(pkgs)[1]

# Node Sets
devs <- sienaNodeSet(num_devs, nodeSetName = "devs")
pkgs <- sienaNodeSet(num_pkgs, nodeSetName = "pkgs")

# Composition Changes for both Node Sets
comp <- sienaCompositionChangeFromFile('data/compositions/comp_change.txt', nodeSet = "devs")
```

## Networks

### Affiliation Network (Two-Mode)

```{r}
# Load adjacency matrices
net1 <- as.matrix(read.table('data/adjacency/net-2021-03-01.txt'))
net2 <- as.matrix(read.table('data/adjacency/net-2021-04-01.txt'))
net3 <- as.matrix(read.table('data/adjacency/net-2021-05-01.txt'))
net4 <- as.matrix(read.table('data/adjacency/net-2021-06-01.txt'))
net5 <- as.matrix(read.table('data/adjacency/net-2021-07-01.txt'))
net6 <- as.matrix(read.table('data/adjacency/net-2021-08-01.txt'))
net7 <- as.matrix(read.table('data/adjacency/net-2021-09-01.txt'))
net8 <- as.matrix(read.table('data/adjacency/net-2021-10-01.txt'))

# Create network object
netList <- list(net1, net2, net3, net4, net5, net6, net7, net8)
netArray <- array(c(net1, net2, net3, net4, net5, net6, net7, net8), dim=c(num_devs, num_pkgs, length(netList)))
net <- sienaDependent(netArray, type="bipartite", nodeSet = c("devs", "pkgs"))

# Check network dimensions
lapply(netList, dim)   # each network has the same number of actors as needed
lapply(netList, function(x) table(x, useNA='always'))
```

### Plot Network

```{r}
g.layout <- gplot(apply(netArray, c(1,2), max), usearrows=T)
par(mfrow=c(1,1))
gplot(netArray[,,8], gmode="twomode",
      arrowhead.cex=.75, edge.col='gray70', coord=g.layout, vertex.cex=1.5)
```

## Individual Variables

### Packages

```{r}
# Dependencies
deps_up     <- as.matrix(read.table('data/individual/pkg_upstream.txt'))
deps_down   <- as.matrix(read.table('data/individual/pkg_downstream.txt'))
depsUpVar   <- varCovar(deps_up, nodeSet = "pkgs")
depsDownVar <- varCovar(deps_down, nodeSet = "pkgs")

deps_up_log    <- log(deps_up + 1)
deps_down_log  <- log(deps_down + 1)
depsUpLogVar   <- varCovar(deps_up_log, nodeSet = "pkgs", centered = T) 
depsDownLogVar <- varCovar(deps_down_log, nodeSet = "pkgs", centered = T)
  
# Community Interest
com_int   <- as.matrix(read.table('data/individual/pkg_community.txt'))
comIntVar <- varCovar(com_int, nodeSet = "pkgs")

com_int_log  <- log(com_int + 1)
comIntLogVar <- varCovar(com_int_log, nodeSet = "pkgs", centered = T)

# Release Activity
releases  <- as.matrix(read.table('data/individual/pkg_releases.txt'))
relActVar <- varCovar(releases, nodeSet = "pkgs")

releases_log <- log(releases + 1)
relActLogVar <- varCovar(releases_log, nodeSet = "pkgs", centered = T)

# Repository Owner Type
# types <- as.matrix(read.table('data/individual/pkg_repo_types.txt'))
# typeVar <- coCovar(types[,1], nodeSet = "pkgs")

# Age
age    <- as.matrix(read.table('data/individual/pkg_age.txt'))
ageVar <- varCovar(age, nodeSet = "pkgs")

age_log <- log(age)
ageLogVar <- varCovar(age_log, nodeSet = "pkgs", centered = T)
```

### Developers

```{r}
dev_act   <- as.matrix(read.table('data/individual/dev_activity.txt'))
devActVar <- varCovar(dev_act, nodeSet = "devs")

dev_act_log <- log(dev_act + 1)
devActLogVar <- varCovar(dev_act_log, nodeSet = "devs", centered = T)
```

## Dyadic Variables

### Upstream Dependencies

```{r}
# Dependency Associations
depUp1 <- as.matrix(read.table('data/dyadic/dep_up_associations-2021-03-01.txt'))
depUp2 <- as.matrix(read.table('data/dyadic/dep_up_associations-2021-04-01.txt'))
depUp3 <- as.matrix(read.table('data/dyadic/dep_up_associations-2021-05-01.txt'))
depUp4 <- as.matrix(read.table('data/dyadic/dep_up_associations-2021-06-01.txt'))
depUp5 <- as.matrix(read.table('data/dyadic/dep_up_associations-2021-07-01.txt'))
depUp6 <- as.matrix(read.table('data/dyadic/dep_up_associations-2021-08-01.txt'))
depUp7 <- as.matrix(read.table('data/dyadic/dep_up_associations-2021-09-01.txt'))
# depUp8 <- as.matrix(read.table('data/dyadic/dep_up_associations-2021-10-01.txt'))
# Last observation not required

# Create network object
depUpList  <- list(depUp1, depUp2, depUp3, depUp4, depUp5, depUp6, depUp7)
depUpArray <- array(c(depUp1, depUp2, depUp3, depUp4, depUp5, depUp6, depUp7),
                    dim=c(num_devs, num_pkgs, length(depUpList)))
depUpDyad  <- varDyadCovar(depUpArray, nodeSets = c("devs", "pkgs"), type = "bipartite")
```

### Downstream Dependencies

```{r}
# Dependency Associations
depDown1 <- as.matrix(read.table('data/dyadic/dep_down_associations-2021-03-01.txt'))
depDown2 <- as.matrix(read.table('data/dyadic/dep_down_associations-2021-04-01.txt'))
depDown3 <- as.matrix(read.table('data/dyadic/dep_down_associations-2021-05-01.txt'))
depDown4 <- as.matrix(read.table('data/dyadic/dep_down_associations-2021-06-01.txt'))
depDown5 <- as.matrix(read.table('data/dyadic/dep_down_associations-2021-07-01.txt'))
depDown6 <- as.matrix(read.table('data/dyadic/dep_down_associations-2021-08-01.txt'))
depDown7 <- as.matrix(read.table('data/dyadic/dep_down_associations-2021-09-01.txt'))
# depDown8 <- as.matrix(read.table('data/dyadic/dep_down_associations-2021-10-01.txt'))

# Create network object
depDownList  <- list(depDown1, depDown2, depDown3, depDown4, depDown5, depDown6, depDown7)
depDownArray <- array(c(depDown1, depDown2, depDown3, depDown4, depDown5, depDown6, depDown7),
                    dim=c(num_devs, num_pkgs, length(depDownList)))
depDownDyad  <- varDyadCovar(depDownArray, nodeSets = c("devs", "pkgs"), type = "bipartite")
```

## Initialization

```{r}
# TODO Add dnet, but then the package sampling needs to be changed
data <- sienaDataCreate(net, comp, devActLogVar,
                        depsUpLogVar, depsDownLogVar, comIntLogVar, relActLogVar, ageLogVar,
                        depUpDyad, depDownDyad,
                        nodeSets = list(devs, pkgs))
# saveRDS(data, "data/sienaData.rds")
print01Report(data, modelname='hicss-2023')
```

# Model Selection

## Initialize Algorithm

```{r}
algorithm <- sienaAlgorithmCreate(projname='hicss-2023', n3=3000) # 1000 standard, 3000 for pub
effects <- getEffects(data, nintn = 50)
effectsDocumentation(effects)
```

## Model 1

```{r}
effects1 <- effects
ans.model1 <- siena07(algorithm, data=data, effects=effects1,
                      batch=F, verbose=F, returnDeps=T, initC=T, useCluster=T,
                      byWave=T, nbrNodes=12)
outTable(ans.model1)
saveRDS(ans.model1, file = "models/model1.rds")
```

```{r}
# Tests
Multipar.RSiena(ans.model1, 8)
score.Test(ans.model1, test= ans.model1$test)
```

```{r}
# GOF
gof.id1 <- sienaGOF(ans.model1, verbose=TRUE, varName="net",
                   IndegreeDistribution, join=T, cumulative=F)
plot(gof.id1)

gof.od1 <- sienaGOF(ans.model1, verbose=TRUE, varName="net",
                    OutdegreeDistribution, join=T, cumulative=F)
plot(gof.od1)
```

```{r}
# Time Heterogeneity
tt1 <- sienaTimeTest(ans.model1)
summary(tt1)
plot(tt1)
```

```{r}
effects1.tt <- includeTimeDummy(effects1, density)
ans.model1.tt <- siena07(algorithm, data=data, effects=effects1.tt,
                         batch=F, verbose=F, returnDeps=T, initC=T, useCluster=T,
                         byWave=T, nbrNodes=12)
outTable(ans.model1.tt)

Multipar.RSiena(ans.model1.tt, 8)

gof.id1.tt <- sienaGOF(ans.model1.tt, verbose=TRUE, varName="net",
                       IndegreeDistribution, join=T, cumulative=F)
plot(gof.id1.tt)

gof.od1.tt <- sienaGOF(ans.model1.tt, verbose=TRUE, varName="net",
                       OutdegreeDistribution, join=T, cumulative=F)
plot(gof.od1.tt)
```


## Model 2

In this model, important structural effects for two-mode networks are tested and
estimated.

- Transitivity-related Effects: Four-Cycles (Robins and Alexander, 2004)
  - Reflects the extent to which actors who make on choice in common also make
    other choices in common.
- Degree-related Effects:
  - Out-degree activity: Tendencies of dispersion in out-degrees of actors
  - In-degree popularity: Tendencies of dispersion in in-degree of column units
  - Out-in degree assortativity effect (param 2 = sqrt, param 1 = non-sqrt): 
    Tendencies for actors with high out-degrees to preferably be tied to column
    units with high in-degrees

```{r}
effects2 <- effects1

# Transitivty
effects2 <- setEffect(effects2, cycle4, fix=T, test=T, include=T)

# Indegree
effects2 <- setEffect(effects2, inPop, fix=T, test=T, include=T)
effects2 <- setEffect(effects2, inPopSqrt, fix=T, test=T, include=T)

# Outdegree
effects2 <- setEffect(effects2, outAct, fix=T, test=T, include=T)
effects2 <- setEffect(effects2, outActSqrt, fix=T, test=T, include=T)

# Out-in degree
effects2 <- setEffect(effects2, outInAss, parameter=1, fix=T, test=T, include=T)

ans.model2.stt <- siena07(algorithm, data=data, effects=effects2,
                          batch=F, verbose=F, returnDeps=T, initC=T, useCluster=T,
                          byWave=T, nbrNodes=12)
summary(ans.model2.stt)
```

Testing the goodness-of-fit of the model restricted by
 (1)   eval:  4-cycles (1)                                =   0.0000
 (2)   eval:  indegree - popularity                       =   0.0000
 (3)   eval:  indegree - popularity (sqrt)                =   0.0000
 (4)   eval:  outdegree - activity                        =   0.0000
 (5)   eval:  outdegree - activity (sqrt)                 =   0.0000
 (6)   eval:  out-in degree^(1/2) assortativity           =   0.0000
_________________________________________________
                   
Joint test:
   c = 3228.8967   d.f. = 6   p-value < 0.0001

(1) tested separately:
 - two-sided:
  c =  48.3646   d.f. = 1  p-value < 0.0001
 - one-sided (normal variate):   6.9545

(2) tested separately:
 - two-sided:
  c = 2422.0791   d.f. = 1  p-value < 0.0001
 - one-sided (normal variate):  49.2146

(3) tested separately:
 - two-sided:
  c = 2272.7568   d.f. = 1  p-value < 0.0001
 - one-sided (normal variate):  47.6734

(4) tested separately:
 - two-sided:
  c = 134.8726   d.f. = 1  p-value < 0.0001
 - one-sided (normal variate): -11.6135

(5) tested separately:
 - two-sided:
  c = 164.9223   d.f. = 1  p-value < 0.0001
 - one-sided (normal variate): -12.8422

(6) tested separately:
 - two-sided:
  c = 1361.6002   d.f. = 1  p-value < 0.0001
 - one-sided (normal variate):  36.8999    

```{r}
effects2 <- effects1

effects2 <- setEffect(effects2, cycle4, fix=F, test=F, include=T)
effects2 <- setEffect(effects2, inPop, fix=F, test=F, include=T)
effects2 <- setEffect(effects2, outInAss, parameter=1, fix=F, test=F, include=T)

ans.model2 <- siena07(algorithm, data=data, effects=effects2,
                      batch=F, verbose=F, returnDeps=T, initC=T, useCluster=T,
                      byWave=T, nbrNodes=12)

outTable(ans.model2)
```

```{r}
# Tests
Multipar.RSiena(ans.model2, c(8:11))
```

```{r}
# GOF
gof.id2 <- sienaGOF(ans.model2, verbose=TRUE, varName="net",
                   IndegreeDistribution, join=T, cumulative=F)
plot(gof.id2)

gof.od2 <- sienaGOF(ans.model2, verbose=TRUE, varName="net",
                    OutdegreeDistribution, join=T, cumulative=F)
plot(gof.od2)
```

```{r}
# Time Heterogeneity
tt2 <- sienaTimeTest(ans.model2)
summary(tt2)
plot(tt2)
```

```{r}
effects2.tt <- includeTimeDummy(effects2, cycle4, inPop, outInAss)

ans.model2.tt <- siena07(algorithm, data=data, effects=effects2.tt,
                         batch=F, verbose=F, returnDeps=T, initC=T, useCluster=T,
                         byWave=T, nbrNodes=12)
outTable(ans.model2.tt)

Multipar.RSiena(ans.model2.tt, 8:11)

gof.id2.tt <- sienaGOF(ans.model2.tt, verbose=TRUE, varName="net",
                       IndegreeDistribution, join=T, cumulative=F)
plot(gof.id2.tt)

gof.od2.tt <- sienaGOF(ans.model2.tt, verbose=TRUE, varName="net",
                       OutdegreeDistribution, join=T, cumulative=F)
plot(gof.od2.tt)
```

## Model 3

```{r}
effects3 <- effects2

effects3 <- setEffect(effects3, egoX, name="net", interaction1="devActLogVar",
                      include=T, test=T, fix=T)
# c =  26.1904   d.f. = 1  p-value < 0.0001
effects3 <- setEffect(effects3, altX, name="net", interaction1="comIntLogVar",
                      include=T, test=T, fix=T)
# c = 134.6000   d.f. = 1  p-value < 0.0001
effects3 <- setEffect(effects3, altX, name="net", interaction1="relActLogVar",
                      include=T, test=T, fix=T)
# c =  23.4735   d.f. = 1  p-value < 0.0001
effects3 <- setEffect(effects3, altX, name="net", interaction1="ageLogVar",
                      include=T, test=T, fix=T)
# c =   0.1200   d.f. = 1  p-value =   0.7291

ans.model3.stt <- siena07(algorithm, data=data, effects=effects3,
                          batch=F, verbose=F, returnDeps=T, initC=T, useCluster=T,
                          byWave=T, nbrNodes=12)
summary(ans.model3.stt)
```

```{r}
effects3 <- effects2

effects3 <- setEffect(effects3, egoX, name="net", interaction1="devActLogVar",
                      include=T, test=F, fix=F)
effects3 <- setEffect(effects3, altX, name="net", interaction1="comIntLogVar",
                      include=T, test=F, fix=F)
effects3 <- setEffect(effects3, altX, name="net", interaction1="relActLogVar",
                      include=T, test=F, fix=F)

ans.model3 <- siena07(algorithm, data=data, effects=effects3,
                      batch=F, verbose=F, returnDeps=T, initC=T, useCluster=T,
                      byWave=T, nbrNodes=12)

outTable(ans.model3)
```

## Model 4

```{r}
effects4 <- effects3

effects4 <- setEffect(effects4, altX, name="net", interaction1="depsUpLogVar",
                      include=T, test=T, fix=T)
effects4 <- setEffect(effects4, altX, name="net", interaction1="depsDownLogVar",
                      include=T, test=T, fix=T)

ans.model4.stt <- siena07(algorithm, data=data, effects=effects4,
                          batch=F, verbose=F, returnDeps=T, initC=T, useCluster=T,
                          byWave=T, nbrNodes=12)
summary(ans.model4.stt)
```

```{r}
effects4 <- effects3

effects4 <- setEffect(effects4, altX, name="net", interaction1="depsUpLogVar",
                      include=T, test=F, fix=F)
effects4 <- setEffect(effects4, altX, name="net", interaction1="depsDownLogVar",
                      include=T, test=F, fix=F)

ans.model4 <- siena07(algorithm, data=data, effects=effects4,
                      batch=F, verbose=F, returnDeps=T, initC=T, useCluster=T,
                      byWave=T, nbrNodes=12)

outTable(ans.model4)
```

## Model 5

Add dyadic effects

```{r}
effects5 <- effects4

effects5 <- setEffect(effects5, X, name="net", interaction1="depUpDyad",
                      include=T, test=T, fix=T)
effects5 <- setEffect(effects5, X, name="net", interaction1="depDownDyad",
                      include=T, test=T, fix=T)

ans.model5.stt <- siena07(algorithm, data=data, effects=effects5,
                          batch=F, verbose=F, returnDeps=T, initC=T, useCluster=T,
                          byWave=T, nbrNodes=12)
summary(ans.model5.stt)
```

```{r}
effects5 <- effects4

effects5 <- setEffect(effects5, X, name="net", interaction1="depUpDyad",
                      include=T, test=F, fix=F)
effects5 <- setEffect(effects5, X, name="net", interaction1="depDownDyad",
                      include=T, test=F, fix=F)

ans.model5 <- siena07(algorithm, data=data, effects=effects5,
                      batch=F, verbose=F, returnDeps=T, initC=T, useCluster=T,
                      byWave=T, nbrNodes=12)

outTable(ans.model5)
```

```{r}
texreg::htmlreg(list(ans.model1, ans.model2, ans.model3, ans.model4, ans.model5),
                stars = c(0.05, 0.01, 0.001),
                single.row = TRUE, include.iterations = FALSE,
                file = 'tables/preliminary.html')
```

```{r}
# GOF
gof.id5 <- sienaGOF(ans.model5, verbose=TRUE, varName="net",
                   IndegreeDistribution, join=T, cumulative=F)
plot(gof.id5)

gof.od5 <- sienaGOF(ans.model5, verbose=TRUE, varName="net",
                    OutdegreeDistribution, join=T, cumulative=F)
plot(gof.od5)
```

## Model 6

More potential effects (described in Amati et al. 2021):

outTrunc: Outdegree truncated at # (2): Developers tend to participate only in 1
