---
title: "RSiena Analysis"
author: "Mario Mueller"
date: "5/19/2022"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(tidygraph)
library(igraph)
library(network)
library(sna)
library(intergraph)
library(RSiena)
library(multiSiena)
library(patchwork)
library(texreg)
# setwd("/Users/mariomueller/Workspace/hicss-2023")
```

# Required Functions

```{r}
# Functions are adapted from tutorial for the Social Networks and Health 
#   workshop at Duke University on May 18, 2018 by David R. Schaefer

outTable <- function(x) {
  coef <- abs(x$theta)
  coefPretty <- sprintf("%.3f", round(coef,3))
  se <- diag(x$covtheta)**.5
  sePretty <- sprintf("%.3f", round(se,3))
  pval <- 2*pnorm(-abs(coef/se))
  symp <- symnum(pval, corr = FALSE,
                 cutpoints = c(0,  .001,.01,.05, .1, 1),
                 symbols = c("***","**","*","."," "))
  convPretty <- sprintf("%.3f", round(abs(x$tconv),3))
  out1 <- noquote(cbind(
    Function = x$effects[[1]], 
    Effect = x$effects[[2]], 
    Coef = coefPretty, 
    StEr = sePretty, 
    Sig = symp, 
    Conv = convPretty))
  out2 <- paste("Maximum Convergence Ratio:", round(x$tconv.max,3))
  return(list(out1,out2))
}
```

# Data Preparation

## Node Sets & Composition Changes

```{r}
# Load Node Lists
devs <- read_csv("./data/nodelists/developers.csv", col_names = TRUE)
pkgs <- read_csv("./data/nodelists/packages.csv", col_names = TRUE)

# Save numbers of developers and packages for network dimensions
num_devs <- dim(devs)[1]
num_pkgs <- dim(pkgs)[1]

# Node Sets
devs <- sienaNodeSet(num_devs, nodeSetName = "devs")
pkgs <- sienaNodeSet(num_pkgs, nodeSetName = "pkgs")

# Composition Changes for both Node Sets
comp <- sienaCompositionChangeFromFile('data/compositions/comp_change.txt', nodeSet = "devs")
```

## Networks

### Affiliation Network (Two-Mode)

```{r}
# Load adjacency matrices
net1 <- as.matrix(read.table('data/adjacency/net-2021-02-01.txt'))
net2 <- as.matrix(read.table('data/adjacency/net-2021-03-01.txt'))
net3 <- as.matrix(read.table('data/adjacency/net-2021-04-01.txt'))
net4 <- as.matrix(read.table('data/adjacency/net-2021-05-01.txt'))

# Create network object
netList <- list(net1, net2, net3, net4)
netArray <- array(c(net1, net2, net3, net4), dim=c(num_devs, num_pkgs, length(netList)))
net <- sienaDependent(netArray, type="bipartite", nodeSet = c("devs", "pkgs"))

# Check network dimensions
lapply(netList, dim)   # each network has the same number of actors as needed
lapply(netList, function(x) table(x, useNA='always'))
```

### Plot Network

```{r}
g.layout <- gplot(apply(netArray, c(1,2), max), usearrows=T)
par(mfrow=c(1,1))
gplot(netArray[,,4], gmode="twomode",
      arrowhead.cex=.75, edge.col='gray70', coord=g.layout, vertex.cex=1.5)
```

## Individual Variables

### Packages

```{r}
# Dependencies
deps_up     <- as.matrix(read.table('data/individual/pkg_upstream.txt'))
deps_down   <- as.matrix(read.table('data/individual/pkg_downstream.txt'))
depsUpVar   <- varCovar(deps_up, nodeSet = "pkgs")
depsDownVar <- varCovar(deps_down, nodeSet = "pkgs")

deps_up_log    <- log(deps_up + 1)
deps_down_log  <- log(deps_down + 1)
depsUpLogVar   <- varCovar(deps_up_log, nodeSet = "pkgs", centered = T) 
depsDownLogVar <- varCovar(deps_down_log, nodeSet = "pkgs", centered = T)
  
# Community Interest
com_int   <- as.matrix(read.table('data/individual/pkg_community.txt'))
comIntVar <- varCovar(com_int, nodeSet = "pkgs")

com_int_log  <- log(com_int + 1)
comIntLogVar <- varCovar(com_int_log, nodeSet = "pkgs", centered = T)

# Release Activity
releases  <- as.matrix(read.table('data/individual/pkg_releases.txt'))
relActVar <- varCovar(releases, nodeSet = "pkgs")

releases_log <- log(releases + 1)
relActLogVar <- varCovar(releases_log, nodeSet = "pkgs", centered = T)

# Repository Owner Type
# types <- as.matrix(read.table('data/individual/pkg_repo_types.txt'))
# typeVar <- coCovar(types[,1], nodeSet = "pkgs")

# Age
age    <- as.matrix(read.table('data/individual/pkg_age.txt'))
ageVar <- varCovar(age, nodeSet = "pkgs")

age_log <- log(age)
ageLogVar <- varCovar(age_log, nodeSet = "pkgs", centered = T)
```

### Developers

```{r}
dev_act   <- as.matrix(read.table('data/individual/dev_activity.txt'))
devActVar <- varCovar(dev_act, nodeSet = "devs")

dev_act_log <- log(dev_act + 1)
devActLogVar <- varCovar(dev_act_log, nodeSet = "devs", centered = T)
```

## Dyadic Variables

### Upstream Dependencies

```{r}
# Dependency Associations
depUp1 <- as.matrix(read.table('data/dyadic/dep_up_associations-2021-02-01.txt'))
depUp2 <- as.matrix(read.table('data/dyadic/dep_up_associations-2021-03-01.txt'))
depUp3 <- as.matrix(read.table('data/dyadic/dep_up_associations-2021-04-01.txt'))
# Last observation not required

# Create network object
depUpList  <- list(depUp1, depUp2, depUp3)
depUpArray <- array(c(depUp1, depUp2, depUp3),
                    dim=c(num_devs, num_pkgs, length(depUpList)))
depUpDyad  <- varDyadCovar(depUpArray, nodeSets = c("devs", "pkgs"), type = "bipartite")
```

### Downstream Dependencies

```{r}
# Dependency Associations
depDown1 <- as.matrix(read.table('data/dyadic/dep_down_associations-2021-02-01.txt'))
depDown2 <- as.matrix(read.table('data/dyadic/dep_down_associations-2021-03-01.txt'))
depDown3 <- as.matrix(read.table('data/dyadic/dep_down_associations-2021-04-01.txt'))

# Create network object
depDownList  <- list(depDown1, depDown2, depDown3)
depDownArray <- array(c(depDown1, depDown2, depDown3),
                    dim=c(num_devs, num_pkgs, length(depDownList)))
depDownDyad  <- varDyadCovar(depDownArray, nodeSets = c("devs", "pkgs"), type = "bipartite")
```

## Initialization

TODO: Add composition change after data accounts properly for joiners

```{r}
data <- sienaDataCreate(net, comp,
                        devActLogVar, comIntLogVar, relActLogVar, ageLogVar,
                        depsUpLogVar, depsDownLogVar, depUpDyad, depDownDyad,
                        nodeSets = list(devs, pkgs))
saveRDS(data, "data/sienaData.rds")
print01Report(data, modelname='hicss-2023-final')
```

# Selected Models

## Initialize Algorithm

```{r}
algorithm <- sienaAlgorithmCreate(projname='hicss-2023-final',
                                  seed=17,
                                  n3=3000) # 1000 standard, 3000 for pub
effects <- getEffects(data, nintn = 50)
effectsDocumentation(effects)
```

## Model 1: Endogenous

```{r}
effects <- getEffects(data, nintn = 50)

effects <- setEffect(effects, inPopSqrt, fix=F, test=F, include=T)
effects <- setEffect(effects, outTrunc, parameter=2, fix=F, test=F, include=T)
effects <- setEffect(effects, outIso, fix=F, test=F, include=T)
effects <- setEffect(effects, antiInIso, fix=F, test=F, include=T)
effects <- setEffect(effects, in2Plus, fix=F, test=F, include=T)
effects <- setEffect(effects, in3Plus, fix=F, test=F, include=T)

model1 <- siena07(algorithm, data=data, effects=effects,
                  batch=F, verbose=F, returnDeps=T, initC=T, useCluster=T,
                  byWave=T, nbrNodes=12)
saveRDS(model1, "models/model1.rds")
siena.table(model1, type="html", file="tables/results_model1.html",
            sig=T)
```


## Model 2: Controls

```{r}
effects <- setEffect(effects, egoX, name="net", interaction1="devActLogVar",
                     fix=F, test=F, include=T)
effects <- setEffect(effects, altX, name="net", interaction1="comIntLogVar",
                     fix=F, test=F, include=T)
effects <- setEffect(effects, altX, name="net", interaction1="relActLogVar",
                     fix=F, test=F, include=T)
effects <- setEffect(effects, altX, name="net", interaction1="ageLogVar",
                     fix=F, test=F, include=T)

model2 <- siena07(algorithm, data=data, effects=effects,
                  batch=F, verbose=F, returnDeps=T, initC=T, useCluster=T,
                  byWave=T, nbrNodes=12)
saveRDS(model2, "models/model2.rds")

siena.table(model2, type="html", file="tables/results_model2.html",
            sig=T)
```


## Model 3: Full

```{r}
effects <- setEffect(effects, altX, name="net", interaction1="depsUpLogVar",
                     fix=F, test=F, include=T)
effects <- setEffect(effects, altX, name="net", interaction1="depsDownLogVar",
                     fix=F, test=F, include=T)
effects <- setEffect(effects, X, name="net", interaction1="depUpDyad",
                     fix=F, test=F, include=T)
effects <- setEffect(effects, X, name="net", interaction1="depDownDyad",
                     fix=F, test=F, include=T)

model3 <- siena07(algorithm, data=data, effects=effects,
                  batch=F, verbose=F, returnDeps=T, initC=T, useCluster=T,
                  byWave=T, nbrNodes=12)
saveRDS(model3, "models/model3.rds")
siena.table(model3, type="html", file="tables/results_model3.html",
            sig=T)

```

## Results Table

```{r}
wald1 <- Multipar.RSiena(model1, c(1:model1$pp))
wald2 <- Multipar.RSiena(model2, c(1:model2$pp))
wald3 <- Multipar.RSiena(model3, c(1:model3$pp))

gof.string1 <- sprintf("%.2f (%d)", wald1$chisquare, wald1$df)
gof.string2 <- sprintf("%.2f (%d)", wald2$chisquare, wald2$df)
gof.string3 <- sprintf("%.2f (%d)", wald3$chisquare, wald3$df)

texreg::htmlreg(list(model1, model2, model3),
                stars = c(0.1, 0.05, 0.01, 0.001),
                single.row = TRUE, include.iterations = FALSE,
                custom.gof.rows = list(
                  "Wald Statistics" = c(gof.string1, gof.string2, gof.string3)),
                file = 'tables/results.html')
```

## Goodness of Fit

```{r}
gof.id.full <- sienaGOF(model3, verbose=TRUE, varName="net",
                        IndegreeDistribution, join=T, cumulative=F)
plot(gof.id.full)

gof.od.full <- sienaGOF(model3, verbose=TRUE, varName="net",
                        OutdegreeDistribution, join=T, cumulative=F)
plot(gof.od.full)
```

## Model 4: Test with outRate

```{r}
effects.fix <- effects

effects.fix <- setEffect(effects.fix, outRate, name="net", type="rate",
                         fix=F, test=F, include=T)
effects.fix <- setEffect(effects.fix, RateX, name="net", type="rate",
                         interaction1="devActLogVar", fix=F, test=F, include=F)
effects.fix <- setEffect(effects.fix, outAct, fix=F, test=F, include=F)

model4 <- siena07(algorithm, data=data, effects=effects.fix,
                  batch=F, verbose=F, returnDeps=T, initC=T, useCluster=T,
                  byWave=T, nbrNodes=12)

wald4 <- Multipar.RSiena(model4, c(1:model4$pp))
gof.string4 <- sprintf("%.2f (%d)", wald4$chisquare, wald4$df)

texreg::htmlreg(list(model1, model2, model3, model4),
                stars = c(0.1, 0.05, 0.01, 0.001),
                single.row = TRUE, include.iterations = FALSE,
                custom.gof.rows = list(
                  "Wald Statistics" = c(gof.string1, gof.string2, gof.string3, gof.string4)),
                file = 'tables/results.html')

gof.id.fix <- sienaGOF(model4, verbose=TRUE, varName="net",
                        IndegreeDistribution, join=T, cumulative=F)
plot(gof.id.fix)

gof.od.fix <- sienaGOF(model4, verbose=TRUE, varName="net",
                        OutdegreeDistribution, join=T, cumulative=F)
plot(gof.od.fix)
```

# Model Forward-Selection

## Model 1

```{r}
effects1 <- effects

ans.model1 <- siena07(algorithm, data=data, effects=effects1,
                      batch=F, verbose=F, returnDeps=T, initC=T, useCluster=T,
                      byWave=T, nbrNodes=12)
outTable(ans.model1)
Multipar.RSiena(ans.model1, ans.model1$pp)  # c = 10276.73, d.f. = 1; two-sided p < 0.001.
```

```{r}
# GOF
gof.id1 <- sienaGOF(ans.model1, verbose=TRUE, varName="net",
                   IndegreeDistribution, join=T, cumulative=F)
plot(gof.id1)

gof.od1 <- sienaGOF(ans.model1, verbose=TRUE, varName="net",
                    OutdegreeDistribution, join=T, cumulative=F)
plot(gof.od1)
```

## Model 2

In this model, important structural effects for two-mode networks are tested and
estimated.

- Transitivity-related Effects: Four-Cycles (Robins and Alexander, 2004)
  - Reflects the extent to which actors who make on choice in common also make
    other choices in common.
- Degree-related Effects:
  - Out-degree activity: Tendencies of dispersion in out-degrees of actors
  - In-degree popularity: Tendencies of dispersion in in-degree of column units
  - Out-in degree assortativity effect (param 2 = sqrt, param 1 = non-sqrt): 
    Tendencies for actors with high out-degrees to preferably be tied to column
    units with high in-degrees

```{r}
effects2 <- effects1

effects2 <- setEffect(effects2, cycle4, fix=T, test=T, include=T)
effects2 <- setEffect(effects2, inPop, fix=T, test=T, include=T)
effects2 <- setEffect(effects2, outAct, fix=T, test=T, include=T)
effects2 <- setEffect(effects2, outTrunc, parameter=2, fix=T, test=T, include=T)
effects2 <- setEffect(effects2, outTrunc2, parameter=3, fix=T, test=T, include=T)
effects2 <- setEffect(effects2, antiInIso, fix=T, test=T, include=T)
effects2 <- setEffect(effects2, antiInIso2, fix=T, test=T, include=T)
effects2 <- setEffect(effects2, outInAss, parameter=1, fix=T, test=T, include=T)

ans.model2.stt <- siena07(algorithm, data=data, effects=effects2,
                          batch=F, verbose=F, returnDeps=T, initC=T, useCluster=T,
                          byWave=T, nbrNodes=12)
summary(ans.model2.stt)
```

```{r}
effects2 <- effects1

effects2 <- setEffect(effects2, cycle4, fix=F, test=F, include=T)
# effects2 <- setEffect(effects2, inPop, fix=F, test=F, include=T)
effects2 <- setEffect(effects2, outAct, fix=F, test=F, include=T)
# outAct removed
# effects2 <- setEffect(effects2, outTrunc, parameter=2, fix=F, test=F, include=T)
# effects2 <- setEffect(effects2, outTrunc2, parameter=3, fix=F, test=F, include=T)
effects2 <- setEffect(effects2, antiInIso, fix=F, test=F, include=T)
effects2 <- setEffect(effects2, antiInIso2, fix=F, test=F, include=T)
effects2 <- setEffect(effects2, outInAss, parameter=1, fix=F, test=F, include=T)
# Correlates strongly with inPop

ans.model2a <- siena07(algorithm, data=data, effects=effects2,
                       batch=F, verbose=F, returnDeps=T, initC=T, useCluster=T,
                       byWave=T, nbrNodes=12)

outTable(ans.model2a)
Multipar.RSiena(ans.model2a, c(1:ans.model2a$pp))
```

```{r}
effects2 <- effects1

effects2 <- setEffect(effects2, cycle4, fix=F, test=F, include=T)
effects2 <- setEffect(effects2, inPop, fix=F, test=F, include=T)
effects2 <- setEffect(effects2, outAct, fix=F, test=F, include=T)
# outAct removed
# effects2 <- setEffect(effects2, outTrunc, parameter=2, fix=F, test=F, include=T)
# effects2 <- setEffect(effects2, outTrunc2, parameter=3, fix=F, test=F, include=T)
effects2 <- setEffect(effects2, antiInIso, fix=F, test=F, include=T)
effects2 <- setEffect(effects2, antiInIso2, fix=F, test=F, include=T)
# effects2 <- setEffect(effects2, outInAss, parameter=1, fix=F, test=F, include=T)
# Correlates strongly with inPop

ans.model2b <- siena07(algorithm, data=data, effects=effects2,
                       batch=F, verbose=F, returnDeps=T, initC=T, useCluster=T,
                       byWave=T, nbrNodes=12)

outTable(ans.model2b)
Multipar.RSiena(ans.model2b, c(1:ans.model2b$pp))
```


```{r}
# GOF
gof.id2b <- sienaGOF(ans.model2b, verbose=TRUE, varName="net",
                     IndegreeDistribution, join=T, cumulative=F)
plot(gof.id2b)

gof.od2b <- sienaGOF(ans.model2b, verbose=TRUE, varName="net",
                     OutdegreeDistribution, join=T, cumulative=F)
plot(gof.od2b)
```

## Model 3

```{r}
effects3 <- effects2

effects3 <- setEffect(effects3, egoX, name="net", interaction1="devActLogVar",
                      include=T, test=T, fix=T)
effects3 <- setEffect(effects3, altX, name="net", interaction1="comIntLogVar",
                      include=T, test=T, fix=T)
effects3 <- setEffect(effects3, altX, name="net", interaction1="relActLogVar",
                      include=T, test=T, fix=T)
effects3 <- setEffect(effects3, altSqX, name="net", interaction1="ageLogVar",
                      include=T, test=T, fix=T)

ans.model3.stt <- siena07(algorithm, data=data, effects=effects3,
                          batch=F, verbose=F, returnDeps=T, initC=T, useCluster=T,
                          byWave=T, nbrNodes=12)
summary(ans.model3.stt)
```

```{r}
effects3 <- effects2

effects3 <- setEffect(effects3, egoX, name="net", interaction1="devActLogVar",
                      include=T, test=F, fix=F)
effects3 <- setEffect(effects3, altX, name="net", interaction1="comIntLogVar",
                      include=T, test=F, fix=F)
effects3 <- setEffect(effects3, altX, name="net", interaction1="relActLogVar",
                      include=T, test=F, fix=F)
effects3 <- setEffect(effects3, altX, name="net", interaction1="ageLogVar",
                      include=T, test=F, fix=F)

ans.model3 <- siena07(algorithm, data=data, effects=effects3,
                      batch=F, verbose=F, returnDeps=T, initC=T, useCluster=T,
                      byWave=T, nbrNodes=12)

outTable(ans.model3)
Multipar.RSiena(ans.model3, c(1:ans.model3$pp))
```

```{r}
# GOF
gof.id3 <- sienaGOF(ans.model3, verbose=TRUE, varName="net",
                   IndegreeDistribution, join=T, cumulative=F)
plot(gof.id3)

gof.od3 <- sienaGOF(ans.model3, verbose=TRUE, varName="net",
                    OutdegreeDistribution, join=T, cumulative=F)
plot(gof.od3)
```

## Model 4

```{r}
effects4 <- effects3

effects4 <- setEffect(effects4, altX, name="net", interaction1="depsUpLogVar",
                      include=T, test=T, fix=T)
effects4 <- setEffect(effects4, altX, name="net", interaction1="depsDownLogVar",
                      include=T, test=T, fix=T)

ans.model4.stt <- siena07(algorithm, data=data, effects=effects4,
                          batch=F, verbose=F, returnDeps=T, initC=T, useCluster=T,
                          byWave=T, nbrNodes=12)
summary(ans.model4.stt)
```

```{r}
effects4 <- effects3

effects4 <- setEffect(effects4, altX, name="net", interaction1="depsUpLogVar",
                      include=T, test=F, fix=F)
effects4 <- setEffect(effects4, altX, name="net", interaction1="depsDownLogVar",
                      include=T, test=F, fix=F)

ans.model4 <- siena07(algorithm, data=data, effects=effects4,
                      batch=F, verbose=F, returnDeps=T, initC=T, useCluster=T,
                      byWave=T, nbrNodes=12)

outTable(ans.model4)
Multipar.RSiena(ans.model4, c(1:ans.model4$pp))
```

```{r}
# GOF
gof.id4 <- sienaGOF(ans.model4, verbose=TRUE, varName="net",
                   IndegreeDistribution, join=T, cumulative=F)
plot(gof.id4)

gof.od4 <- sienaGOF(ans.model4, verbose=TRUE, varName="net",
                    OutdegreeDistribution, join=T, cumulative=F)
plot(gof.od4)
```

## Model 5

Add dyadic effects

```{r}
effects5 <- effects4

effects5 <- setEffect(effects5, X, name="net", interaction1="depUpDyad",
                      include=T, test=T, fix=T)
effects5 <- setEffect(effects5, X, name="net", interaction1="depDownDyad",
                      include=T, test=T, fix=T)

ans.model5.stt <- siena07(algorithm, data=data, effects=effects5,
                          batch=F, verbose=F, returnDeps=T, initC=T, useCluster=T,
                          byWave=T, nbrNodes=12)
summary(ans.model5.stt)
```

```{r}
effects5 <- effects4

effects5 <- setEffect(effects5, X, name="net", interaction1="depUpDyad",
                      include=T, test=F, fix=F)
effects5 <- setEffect(effects5, X, name="net", interaction1="depDownDyad",
                      include=T, test=F, fix=F)

ans.model5 <- siena07(algorithm, data=data, effects=effects5,
                      batch=F, verbose=F, returnDeps=T, initC=T, useCluster=T,
                      byWave=T, nbrNodes=12)

outTable(ans.model5)
Multipar.RSiena(ans.model5, c(1:ans.model5$pp))
```

```{r}
# GOF
gof.id5 <- sienaGOF(ans.model5, verbose=TRUE, varName="net",
                   IndegreeDistribution, join=T, cumulative=F)
plot(gof.id5)

gof.od5 <- sienaGOF(ans.model5, verbose=TRUE, varName="net",
                    OutdegreeDistribution, join=T, cumulative=F)
plot(gof.od5)
```

## Model 6

```{r}
effects6 <- effects5

effects6 <- setEffect(effects6, outRateLog, name="net", type="rate",
                      include=T, test=F, fix=F)

ans.model6 <- siena07(algorithm, data=data, effects=effects6,
                      batch=F, verbose=F, returnDeps=T, initC=T, useCluster=T,
                      byWave=T, nbrNodes=12)

outTable(ans.model6)
Multipar.RSiena(ans.model6, c(1:ans.model6$pp))
```

```{r}
# GOF
gof.id6 <- sienaGOF(ans.model6, verbose=TRUE, varName="net",
                   IndegreeDistribution, join=T, cumulative=F)
plot(gof.id6)

gof.od6 <- sienaGOF(ans.model6, verbose=TRUE, varName="net",
                    OutdegreeDistribution, join=T, cumulative=F)
plot(gof.od6)
```

# Model Backward-Selection

## Model 7

```{r}
effects7 <- effects6

effects7 <- setEffect(effects7, outAct, fix=F, test=F, include=F)

ans.model7 <- siena07(algorithm, data=data, effects=effects7,
                      batch=F, verbose=F, returnDeps=T, initC=T, useCluster=T,
                      byWave=T, nbrNodes=12)

outTable(ans.model7)
Multipar.RSiena(ans.model7, c(1:ans.model7$pp))

gof.id7 <- sienaGOF(ans.model7, verbose=TRUE, varName="net",
                   IndegreeDistribution, join=T, cumulative=F)
plot(gof.id7)

gof.od7 <- sienaGOF(ans.model7, verbose=TRUE, varName="net",
                    OutdegreeDistribution, join=T, cumulative=F)
plot(gof.od7)
```

## Model 8

```{r}
effects8 <- effects7

effects8 <- setEffect(effects8, inPop, fix=F, test=F, include=F)
effects8 <- setEffect(effects8, inPopSqrt, fix=F, test=F, include=T)

effects8 <- setEffect(effects8, cycle4, fix=F, test=F, include=F)
# effects8 <- setEffect(effects8, antiInIso, fix=F, test=F, include=F)
effects8 <- setEffect(effects8, antiInIso2, fix=F, test=F, include=F)

# effects8 <- setEffect(effects8, outRateLog, name="net", type="rate",
#                       include=F, test=F, fix=F)

ans.model8 <- siena07(algorithm, data=data, effects=effects8,
                      batch=F, verbose=F, returnDeps=T, initC=T, useCluster=T,
                      byWave=T, nbrNodes=12)

outTable(ans.model8)
Multipar.RSiena(ans.model8, c(1:ans.model8$pp))

gof.id8 <- sienaGOF(ans.model8, verbose=TRUE, varName="net",
                    IndegreeDistribution, join=T, cumulative=F)
plot(gof.id8)

gof.od8 <- sienaGOF(ans.model8, verbose=TRUE, varName="net",
                    OutdegreeDistribution, join=T, cumulative=F)
plot(gof.od8)
```

Best Model Yet:

[[1]]
      Function Effect                             Coef  StEr  Sig Conv 
 [1,] net      effect ln(outdegree+1) on rate net 0.207 0.208     0.047
 [2,] net      outdegree (density)                5.245 0.110 *** 0.012
 [3,] net      indegree - popularity (sqrt)       0.361 0.025 *** 0.002
 [4,] net      anti in-isolates                   0.567 0.153 *** 0.030
 [5,] net      depUpDyad                          1.906 0.492 *** 0.049
 [6,] net      depDownDyad                        1.637 0.400 *** 0.039
 [7,] net      devActLogVar ego                   0.214 0.026 *** 0.005
 [8,] net      depsUpLogVar alter                 0.085 0.025 *** 0.017
 [9,] net      depsDownLogVar alter               0.007 0.033     0.008
[10,] net      comIntLogVar alter                 0.213 0.028 *** 0.005
[11,] net      relActLogVar alter                 0.068 0.044     0.024
[12,] net      ageLogVar alter                    0.100 0.050 *   0.006

[[2]]
[1] "Maximum Convergence Ratio: 0.088"

Indegree Distribution: p: 0.029

## Model 9

```{r}
effects9 <- effects8

# With both indegree effects > p 0.118
effects9 <- setEffect(effects9, in2Plus, fix=F, test=F, include=T)
effects9 <- setEffect(effects9, in3Plus, fix=F, test=F, include=T)

ans.model9 <- siena07(algorithm, data=data, effects=effects9,
                      batch=F, verbose=F, returnDeps=T, initC=T, useCluster=T,
                      byWave=T, nbrNodes=12)

outTable(ans.model9)
Multipar.RSiena(ans.model9, c(1:ans.model9$pp))

gof.id9 <- sienaGOF(ans.model9, verbose=TRUE, varName="net",
                    IndegreeDistribution, join=T, cumulative=F)
plot(gof.id9)

gof.od9 <- sienaGOF(ans.model9, verbose=TRUE, varName="net",
                    OutdegreeDistribution, join=T, cumulative=F)
plot(gof.od9)
```

## Model 10

```{r}
effects10 <- effects9

effects10 <- setEffect(effects10, outRateLog, name="net", type="rate",
                       include=F, test=F, fix=F)

# This effect is nice! Improves GOF for Indegree and significant
effects10 <- setEffect(effects10, outIso, fix=F, test=F, include=T)
effects10 <- setEffect(effects10, outTrunc, parameter=2, fix=F, test=F, include=T)
# CONTINUE TODO Add outTrunc with varying parameter to improve GOF OD
# effects10 <- setEffect(effects10, outMore, fix=F, test=F, include=T)

ans.model10 <- siena07(algorithm, data=data, effects=effects10,
                       batch=F, verbose=F, returnDeps=T, initC=T, useCluster=T,
                       byWave=T, nbrNodes=12)

outTable(ans.model10)
Multipar.RSiena(ans.model10, c(1:ans.model10$pp))

gof.id10 <- sienaGOF(ans.model10, verbose=TRUE, varName="net",
                     IndegreeDistribution, join=T, cumulative=F)
plot(gof.id10)

gof.od10 <- sienaGOF(ans.model10, verbose=TRUE, varName="net",
                     OutdegreeDistribution, join=T, cumulative=F)
plot(gof.od10)
```
