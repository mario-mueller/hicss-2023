---
title: "RSiena Analysis"
author: "Mario Mueller"
date: "5/19/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(tidygraph)
library(igraph)
library(network)
library(sna)
library(intergraph)
library(RSiena)
library(patchwork)
library(texreg)
# setwd("/Users/mariomueller/Workspace/hicss-2023")
```

# Required Functions

```{r}
# Functions are adapted from tutorial for the Social Networks and Health 
#   workshop at Duke University on May 18, 2018 by David R. Schaefer

outTable <- function(x) {
  coef <- abs(x$theta)
  coefPretty <- sprintf("%.3f", round(coef,3))
  se <- diag(x$covtheta)**.5
  sePretty <- sprintf("%.3f", round(se,3))
  pval <- 2*pnorm(-abs(coef/se))
  symp <- symnum(pval, corr = FALSE,
                 cutpoints = c(0,  .001,.01,.05, .1, 1),
                 symbols = c("***","**","*","."," "))
  convPretty <- sprintf("%.3f", round(abs(x$tconv),3))
  out1 <- noquote(cbind(
    Function = x$effects[[1]], 
    Effect = x$effects[[2]], 
    Coef = coefPretty, 
    StEr = sePretty, 
    Sig = symp, 
    Conv = convPretty))
  out2 <- paste("Maximum Convergence Ratio:", round(x$tconv.max,3))
  return(list(out1,out2))
}
```

# Data Preparation

## Node Sets & Composition Changes

```{r}
# Load Node Lists
devs <- read_csv("./data/nodelists/developers.csv", col_names = TRUE)
pkgs <- read_csv("./data/nodelists/packages.csv", col_names = TRUE)

# Save numbers of developers and packages for network dimensions
num_devs <- dim(devs)[1]
num_pkgs <- dim(pkgs)[1]

# Node Sets
devs <- sienaNodeSet(num_devs, nodeSetName = "devs")
pkgs <- sienaNodeSet(num_pkgs, nodeSetName = "pkgs")

# Composition Changes for both Node Sets
comp <- sienaCompositionChangeFromFile('data/compositions/comp_change.txt', nodeSet = "devs")
```

## Networks

### Affiliation Network (Two-Mode)

```{r}
# Load adjacency matrices
net1 <- as.matrix(read.table('data/adjacency/net-2021-03-01.txt'))
net2 <- as.matrix(read.table('data/adjacency/net-2021-04-01.txt'))
net3 <- as.matrix(read.table('data/adjacency/net-2021-05-01.txt'))
net4 <- as.matrix(read.table('data/adjacency/net-2021-06-01.txt'))
net5 <- as.matrix(read.table('data/adjacency/net-2021-07-01.txt'))
net6 <- as.matrix(read.table('data/adjacency/net-2021-08-01.txt'))
net7 <- as.matrix(read.table('data/adjacency/net-2021-09-01.txt'))
net8 <- as.matrix(read.table('data/adjacency/net-2021-10-01.txt'))

# Create network object
netList <- list(net1, net2, net3, net4, net5, net6, net7, net8)
netArray <- array(c(net1, net2, net3, net4, net5, net6, net7, net8), dim=c(num_devs, num_pkgs, length(netList)))
net <- sienaDependent(netArray, type="bipartite", nodeSet = c("devs", "pkgs"))

# Check network dimensions
lapply(netList, dim)   # each network has the same number of actors as needed
lapply(netList, function(x) table(x, useNA='always'))
```

```{r}
# Plot Network Changes
g.layout <- gplot(apply(netArray, c(1,2), max), usearrows=T)

par(mfrow=c(3,3))
for (i in 1:8) {
  gplot(netArray[,,i], arrowhead.cex=.75, edge.col='gray70', coord=g.layout, 	
        vertex.cex=1.5, main=paste('Affiliation Network t',i,sep="") )
}
```

#### Plot Single Affiliation Network

```{r}
g.layout <- gplot(apply(netArray, c(1,2), max), usearrows=T)
par(mfrow=c(1,1))
gplot(netArray[,,8], gmode="twomode",
      arrowhead.cex=.75, edge.col='gray70', coord=g.layout, vertex.cex=1.5)
```


### Dependency Network (One-Mode)

```{r}
# Load adjacency matrices
dnet1 <- as.matrix(read.table('data/adjacency/dnet-2021-03-01.txt'))
dnet2 <- as.matrix(read.table('data/adjacency/dnet-2021-04-01.txt'))
dnet3 <- as.matrix(read.table('data/adjacency/dnet-2021-05-01.txt'))
dnet4 <- as.matrix(read.table('data/adjacency/dnet-2021-06-01.txt'))
dnet5 <- as.matrix(read.table('data/adjacency/dnet-2021-07-01.txt'))
dnet6 <- as.matrix(read.table('data/adjacency/dnet-2021-08-01.txt'))
dnet7 <- as.matrix(read.table('data/adjacency/dnet-2021-09-01.txt'))
dnet8 <- as.matrix(read.table('data/adjacency/dnet-2021-10-01.txt'))

# Create network object
dnetList <- list(dnet1, dnet2, dnet3, dnet4, dnet5, dnet6, dnet7, dnet8)
dnetArray <- array(c(dnet1, dnet2, dnet3, dnet4, dnet5, dnet6, dnet7, dnet8), dim=c(num_pkgs, num_pkgs, length(dnetList)))
dnet <- sienaDependent(dnetArray, type="oneMode", nodeSet = "pkgs")

# Check network dimensions
lapply(dnetList, dim)   # each network has the same number of actors as needed
lapply(dnetList, function(x) table(x, useNA='always'))
```

```{r}
# Plot Network Changes
g.layout <- gplot(apply(dnetArray, c(1,2), max), usearrows=T)

par(mfrow=c(3,3))
for (i in 1:8) {
  gplot(dnetArray[,,i], arrowhead.cex=.75, edge.col='gray70', coord=g.layout, 	
        vertex.cex=1.5, main=paste('Dependency Network t',i,sep="") )
}
```

## Individual Variables

### Packages

```{r}
# Dependencies
deps_up     <- as.matrix(read.table('data/individual/pkg_upstream.txt'))
deps_down   <- as.matrix(read.table('data/individual/pkg_downstream.txt'))
depsUpVar   <- varCovar(deps_up, nodeSet = "pkgs")
depsDownVar <- varCovar(deps_down, nodeSet = "pkgs")

deps_up_log    <- log(deps_up + 1)
deps_down_log  <- log(deps_down + 1)
depsUpLogVar   <- varCovar(deps_up_log, nodeSet = "pkgs", centered = T) 
depsDownLogVar <- varCovar(deps_down_log, nodeSet = "pkgs", centered = T)
  
# Community Interest
com_int   <- as.matrix(read.table('data/individual/pkg_community.txt'))
comIntVar <- varCovar(com_int, nodeSet = "pkgs")

com_int_log  <- log(com_int + 1)
comIntLogVar <- varCovar(com_int_log, nodeSet = "pkgs", centered = T)

# Release Activity
releases  <- as.matrix(read.table('data/individual/pkg_releases.txt'))
relActVar <- varCovar(releases, nodeSet = "pkgs")

releases_log <- log(releases + 1)
relActLogVar <- varCovar(releases_log, nodeSet = "pkgs", centered = T)

# Age
age    <- as.matrix(read.table('data/individual/pkg_age.txt'))
ageVar <- varCovar(age, nodeSet = "pkgs")

age_log <- log(age)
ageLogVar <- varCovar(age_log, nodeSet = "pkgs", centered = T)
```

### Developers

```{r}
dev_act   <- as.matrix(read.table('data/individual/dev_activity.txt'))
devActVar <- varCovar(dev_act, nodeSet = "devs")

dev_act_log <- log(dev_act + 1)
devActLogVar <- varCovar(dev_act_log, nodeSet = "devs", centered = T)
```

## Dyadic Variables

### Upstream Dependencies

```{r}
# Dependency Associations
depUp1 <- as.matrix(read.table('data/dyadic/dep_up_associations-2021-03-01.txt'))
depUp2 <- as.matrix(read.table('data/dyadic/dep_up_associations-2021-04-01.txt'))
depUp3 <- as.matrix(read.table('data/dyadic/dep_up_associations-2021-05-01.txt'))
depUp4 <- as.matrix(read.table('data/dyadic/dep_up_associations-2021-06-01.txt'))
depUp5 <- as.matrix(read.table('data/dyadic/dep_up_associations-2021-07-01.txt'))
depUp6 <- as.matrix(read.table('data/dyadic/dep_up_associations-2021-08-01.txt'))
depUp7 <- as.matrix(read.table('data/dyadic/dep_up_associations-2021-09-01.txt'))
# depUp8 <- as.matrix(read.table('data/dyadic/dep_up_associations-2021-10-01.txt'))
# Last observation not required

# Create network object
depUpList  <- list(depUp1, depUp2, depUp3, depUp4, depUp5, depUp6, depUp7)
depUpArray <- array(c(depUp1, depUp2, depUp3, depUp4, depUp5, depUp6, depUp7),
                    dim=c(num_devs, num_pkgs, length(depUpList)))
depUpDyad  <- varDyadCovar(depUpArray, nodeSets = c("devs", "pkgs"), type = "bipartite")
```

### Downstream Dependencies

```{r}
# Dependency Associations
depDown1 <- as.matrix(read.table('data/dyadic/dep_down_associations-2021-03-01.txt'))
depDown2 <- as.matrix(read.table('data/dyadic/dep_down_associations-2021-04-01.txt'))
depDown3 <- as.matrix(read.table('data/dyadic/dep_down_associations-2021-05-01.txt'))
depDown4 <- as.matrix(read.table('data/dyadic/dep_down_associations-2021-06-01.txt'))
depDown5 <- as.matrix(read.table('data/dyadic/dep_down_associations-2021-07-01.txt'))
depDown6 <- as.matrix(read.table('data/dyadic/dep_down_associations-2021-08-01.txt'))
depDown7 <- as.matrix(read.table('data/dyadic/dep_down_associations-2021-09-01.txt'))
# depDown8 <- as.matrix(read.table('data/dyadic/dep_down_associations-2021-10-01.txt'))

# Create network object
depDownList  <- list(depDown1, depDown2, depDown3, depDown4, depDown5, depDown6, depDown7)
depDownArray <- array(c(depDown1, depDown2, depDown3, depDown4, depDown5, depDown6, depDown7),
                    dim=c(num_devs, num_pkgs, length(depDownList)))
depDownDyad  <- varDyadCovar(depDownArray, nodeSets = c("devs", "pkgs"), type = "bipartite")
```

## Initialization

```{r}
# TODO Add dnet, but then the package sampling needs to be changed
data <- sienaDataCreate(net, comp, devActLogVar,
                        depsUpLogVar, depsDownLogVar, comIntLogVar, relActLogVar, ageLogVar,
                        depUpDyad, depDownDyad,
                        nodeSets = list(devs, pkgs))

print01Report(data, modelname='hicss-2023')
```

# Model Selection

```{r}
algorithm <- sienaAlgorithmCreate(projname='hicss-2023')
effects <- getEffects(data)
effectsDocumentation(effects)


ans.model0 <- siena07(algorithm, data=data, effects=effects,
                      batch=F, verbose=F, returnDeps=T, initC=T, useCluster=T,
                      nbrNodes=12)

outTable(ans.model0)

wald0 <- Multipar.RSiena(ans.model0, 8)
gof.string0 <- sprintf("%.2f (%d)", wald0$chisquare, wald0$df)

texreg::htmlreg(ans.model0,
                single.row = TRUE, include.iterations = FALSE,
                custom.gof.rows = list("Wald Statistics" = gof.string0),
                file = 'tables/model0.html')

saveRDS(ans.model0, file = "models/model0.rds")
```

## Endogenous Effects

```{r}
effects <- setEffect(effects, inPopSqrt, name="net", include=T, test=F, fix=F)

ans.model1 <- siena07(algorithm, data=data, effects=effects,
                      batch=F, verbose=F, returnDeps=T, initC=T, useCluster=T,
                      nbrNodes=12)
wald1 <- Multipar.RSiena(ans.model1, c(8:9))
gof.string1 <- sprintf("%.2f (%d)", wald1$chisquare, wald1$df)

outTable(ans.model1)
texreg::htmlreg(list(ans.model0, ans.model1),
                stars = c(0.05, 0.01, 0.001),
                single.row = TRUE, include.iterations = FALSE,
                custom.gof.rows = list("Wald Statistics" = c(gof.string0, gof.string1)),
                file = 'tables/model1.html')
saveRDS(ans.model1, file = "models/model1.rds")
```

```{r}
effects <- setEffect(effects, inPopSqrt, name="net", include=T, test=F, fix=F)
effects <- setEffect(effects, outActSqrt, name="net", include=T, test=F, fix=F)

ans.model2 <- siena07(algorithm, data=data, effects=effects,
                      batch=F, verbose=F, returnDeps=T, initC=T, useCluster=T,
                      nbrNodes=12)
wald2 <- Multipar.RSiena(ans.model2, c(8:10))
gof.string2 <- sprintf("%.2f (%d)", wald2$chisquare, wald2$df)

outTable(ans.model2)
texreg::htmlreg(list(ans.model0, ans.model1, ans.model2),
                stars = c(0.05, 0.01, 0.001),
                single.row = TRUE, include.iterations = FALSE,
                custom.gof.rows = list(
                  "Wald Statistics" = c(gof.string0, gof.string1, gof.string2)),
                file = 'tables/model2.html')
saveRDS(ans.model2, file = "models/model2.rds")
```

```{r}
effects <- setEffect(effects, inPopSqrt, name="net", include=T, test=F, fix=F)
# chi-square lower with outActSqrt
effects <- setEffect(effects, outActSqrt, name="net", include=T, test=F, fix=F)
effects <- setEffect(effects, outInAss, name="net", include=T, test=F, fix=F)

ans.model3 <- siena07(algorithm, data=data, effects=effects,
                      batch=F, verbose=F, returnDeps=T, initC=T, useCluster=T,
                      nbrNodes=12)
wald3 <- Multipar.RSiena(ans.model3, c(8:11))
gof.string3 <- sprintf("%.2f (%d)", wald3$chisquare, wald3$df)

outTable(ans.model3)
texreg::htmlreg(list(ans.model0, ans.model1, ans.model2, ans.model3),
                stars = c(0.05, 0.01, 0.001),
                single.row = TRUE, include.iterations = FALSE,
                custom.gof.rows = list(
                  "Wald Statistics" = c(gof.string0, gof.string1, gof.string2, gof.string3)),
                file = 'tables/model3.html')
saveRDS(ans.model3, file = "models/model3.rds")
```

```{r}
effects <- setEffect(effects, inPopSqrt, name="net", include=T, test=F, fix=F)
# chi-square lower with outActSqrt
effects <- setEffect(effects, outActSqrt, name="net", include=T, test=F, fix=F)
# chi-square lower with outInAss
effects <- setEffect(effects, outInAss, name="net", include=T, test=F, fix=F)
effects <- setEffect(effects, cycle4, name="net", include=T, test=F, fix=F)  # Okayish, but does not add much value yet

ans.model4 <- siena07(algorithm, data=data, effects=effects,
                      batch=F, verbose=F, returnDeps=T, initC=T, useCluster=T,
                      nbrNodes=12)
wald4 <- Multipar.RSiena(ans.model4, c(8:12))
gof.string4 <- sprintf("%.2f (%d)", wald4$chisquare, wald4$df)

outTable(ans.model4)
texreg::htmlreg(list(ans.model0, ans.model1, ans.model2, ans.model3, ans.model4),
                stars = c(0.05, 0.01, 0.001),
                single.row = TRUE, include.iterations = FALSE,
                custom.gof.rows = list(
                  "Wald Statistics" = c(
                    gof.string0, gof.string1, gof.string2, gof.string3, gof.string4)),
                file = 'tables/model4.html')
saveRDS(ans.model4, file = "models/model4.rds")
```

## Exogenous Effects

```{r}
# Add control variables
effects <- setEffect(effects, altX, name="net", interaction1="comIntLogVar",
                     include=T, test=F, fix=F)
effects <- setEffect(effects, altX, name="net", interaction1="relActLogVar",
                     include=T, test=F, fix=F)
effects <- setEffect(effects, altX, name="net", interaction1="ageLogVar",
                     include=T, test=F, fix=F)
effects <- setEffect(effects, egoX, name="net", interaction1="devActLogVar",
                     include=T, test=F, fix=F)

ans.model5 <- siena07(algorithm, data=data, effects=effects,
                      batch=F, verbose=F, returnDeps=T, initC=T, useCluster=T,
                      nbrNodes=12)

wald5 <- Multipar.RSiena(ans.model5, c(8:16))
gof.string5 <- sprintf("%.2f (%d)", wald5$chisquare, wald5$df)

outTable(ans.model5)
texreg::htmlreg(list(ans.model0, ans.model1, ans.model2, ans.model3, ans.model4, ans.model5),
                stars = c(0.05, 0.01, 0.001),
                single.row = TRUE, include.iterations = FALSE,
                custom.gof.rows = list(
                  "Wald Statistics" = c(
                    gof.string0, gof.string1, gof.string2, gof.string3, gof.string4, gof.string5)),
                file = 'tables/model5.html')
saveRDS(ans.model5, file = "models/model5.rds")
```

```{r}
# High convergence value
effects <- setEffect(effects, outActSqrt, name="net", include=F, test=F, fix=F)
ans.model6 <- siena07(algorithm, data=data, effects=effects,
                      batch=F, verbose=F, returnDeps=T, initC=T, useCluster=T,
                      nbrNodes=12)

wald6 <- Multipar.RSiena(ans.model6, c(8:15))
gof.string6 <- sprintf("%.2f (%d)", wald6$chisquare, wald6$df)

outTable(ans.model6)
texreg::htmlreg(list(ans.model0, ans.model1, ans.model2, ans.model3,
                     ans.model4, ans.model5, ans.model6),
                stars = c(0.05, 0.01, 0.001),
                single.row = TRUE, include.iterations = FALSE,
                custom.gof.rows = list(
                  "Wald Statistics" = c(
                    gof.string0, gof.string1, gof.string2, gof.string3,
                    gof.string4, gof.string5, gof.string6)),
                file = 'tables/model6.html')
saveRDS(ans.model6, file = "models/model6.rds")
```

```{r}
# Add dyadic effects
effects <- setEffect(effects, X, name="net", interaction1="depUpDyad",
                     include=T, test=F, fix=F)
effects <- setEffect(effects, X, name="net", interaction1="depDownDyad",
                     include=T, test=F, fix=F)

ans.model7 <- siena07(algorithm, data=data, effects=effects,
                      batch=F, verbose=F, returnDeps=T, initC=T, useCluster=T,
                      nbrNodes=12)

wald7 <- Multipar.RSiena(ans.model7, c(8:17))
gof.string7 <- sprintf("%.2f (%d)", wald7$chisquare, wald7$df)

outTable(ans.model7)
texreg::htmlreg(list(ans.model0, ans.model1, ans.model2, ans.model3,
                     ans.model4, ans.model5, ans.model6, ans.model7),
                stars = c(0.05, 0.01, 0.001),
                single.row = TRUE, include.iterations = FALSE,
                custom.gof.rows = list(
                  "Wald Statistics" = c(
                    gof.string0, gof.string1, gof.string2, gof.string3,
                    gof.string4, gof.string5, gof.string6, gof.string7)),
                file = 'tables/model7.html')
saveRDS(ans.model7, file = "models/model7.rds")
```

```{r}
effects <- setEffect(effects, outActSqrt, name="net", include=T, test=F, fix=F)

ans.model8 <- siena07(algorithm, data=data, effects=effects,
                      batch=F, verbose=F, returnDeps=T, initC=T, useCluster=T,
                      nbrNodes=12)

wald8 <- Multipar.RSiena(ans.model8, c(8:18))
gof.string8 <- sprintf("%.2f (%d)", wald8$chisquare, wald8$df)

outTable(ans.model8)
texreg::htmlreg(list(ans.model0, ans.model1, ans.model2, ans.model3,
                     ans.model4, ans.model5, ans.model6, ans.model7,
                     ans.model8),
                stars = c(0.05, 0.01, 0.001),
                single.row = TRUE, include.iterations = FALSE,
                custom.gof.rows = list(
                  "Wald Statistics" = c(
                    gof.string0, gof.string1, gof.string2, gof.string3,
                    gof.string4, gof.string5, gof.string6, gof.string7,
                    gof.string8)),
                file = 'tables/model8.html')
saveRDS(ans.model8, file = "models/model8.rds")
```


```{r}
# Best Model
# But not regarding Wald test
ans.model.full <- readRDS("models/archive/full.rds")
```


## Guided Selection

```{r}
effects <- setEffect(effects, inPopSqrt, name="net", include=T, test=F, fix=F)
effects <- setEffect(effects, outActSqrt, name="net", include=F, test=F, fix=F)
effects <- setEffect(effects, outInAss, name="net", include=T, test=F, fix=F)
effects <- setEffect(effects, cycle4, name="net", include=T, test=F, fix=F)
effects <- setEffect(effects, outRate, name="net", type="rate", include=F, test=F, fix=F)
effects <- setEffect(effects, in2Plus, name="net", include=F, test=F, fix=F)
effects <- setEffect(effects, in3Plus, name="net", include=F, test=F, fix=F)
effects <- setEffect(effects, outIso, name="net", include=F, test=F, fix=F)
effects <- setEffect(effects, outInv, name="net", include=F, test=F, fix=F)
effects <- setEffect(effects, antiInIso, name="net", include=F, test=F, fix=F)

ans.model1 <- siena07(algorithm, data=data, effects=effects,
                      batch=F, verbose=F, returnDeps=T, initC=T, useCluster=T,
                      nbrNodes=12)
summary(ans.model1)
outTable(ans.model1)
saveRDS(ans.model1, file = "models/endogenous_effects.rds")

gof.id <- sienaGOF(ans.model1, verbose=TRUE, varName="net",
                   IndegreeDistribution, join=T, cumulative=F)
plot(gof.id)

gof.od <- sienaGOF(ans.model1, verbose=TRUE, varName="net",
                   OutdegreeDistribution, join=T, cumulative=F)
plot(gof.od)
```

```{r}
tt1 <- sienaTimeTest(ans.model1)
summary(tt1)
plot(tt1)
```

```{r}
# Include Time Dummies and run again
effects <- includeTimeDummy(effects, density, timeDummy = "4", include=T)
effects <- includeTimeDummy(effects, cycle4, timeDummy = "all", include=T)
effects <- includeTimeDummy(effects, inPop, timeDummy = "all", include=T)
effects <- includeTimeDummy(effects, outAct, timeDummy = "5", include=T)
effects <- includeTimeDummy(effects, outInAss, timeDummy = "all", include=T)

ans.model1 <- siena07(algorithm, data=data, effects=effects,
                      batch=F, verbose=F, returnDeps=T, initC=T, useCluster=T,
                      nbrNodes=12)

summary(ans.model1)
outTable(ans.model1)
saveRDS(ans.model1, file = "models/endogenous_effects.rds")
```


```{r}
effects <- setEffect(effects, altX, name="net", interaction1="comIntVar",
                     include=T, test=F, fix=F)
effects <- setEffect(effects, altX, name="net", interaction1="relActVar",
                     include=T, test=F, fix=F)
effects <- setEffect(effects, altX, name="net", interaction1="ageVar",
                     include=T, test=F, fix=F)

effects <- setEffect(effects, altX, name="net", interaction1="depsUpVar",
                     include=T, test=F, fix=F)
effects <- setEffect(effects, altX, name="net", interaction1="depsDownVar",
                     include=T, test=F, fix=F)

# Include time dummies
# effects <- includeTimeDummy(effects, density, timeDummy = "4", include=T)
# effects <- includeTimeDummy(effects, cycle4, timeDummy = "all", include=T)
# effects <- includeTimeDummy(effects, inPop, timeDummy = "2 3 4 5 7", include=T)
# effects <- includeTimeDummy(effects, outAct, timeDummy = "5", include=T)
# effects <- includeTimeDummy(effects, outInAss, timeDummy = "3 4", include=T)
# effects <- includeTimeDummy(effects, altX, timeDummy = "2 3 4 7", name="net", interaction1="comIntVar", include=T)
# effects <- includeTimeDummy(effects, altX, timeDummy = "all", name="net", interaction1="relActVar", include=T)

ans.model2 <- siena07(algorithm, data=data, effects=effects,
                      batch=F, verbose=F, returnDeps=T, initC=T, useCluster=T,
                      nbrNodes=12)

summary(ans.model2)
outTable(ans.model2)
saveRDS(ans.model2, file = "models/exogenous_effects.rds")

gof.id <- sienaGOF(ans.model2, verbose=TRUE, varName="net",
                   IndegreeDistribution, join=T, cumulative=F)
plot(gof.id)

gof.od <- sienaGOF(ans.model2, verbose=TRUE, varName="net",
                   OutdegreeDistribution, join=T, cumulative=F)
plot(gof.od)
```


```{r}
effects <- setEffect(effects, homXOutAct, name="net", interaction1="depsUpVar",
                     include=F, test=F, fix=F)

effects <- setEffect(effects, X, name="net", interaction1="depUpDyad",
                     include=T, test=F, fix=F)
effects <- setEffect(effects, X, name="net", interaction1="depDownDyad",
                     include=T, test=F, fix=F)

ans.model3 <- siena07(algorithm, data=data, effects=effects,
                      batch=F, verbose=F, returnDeps=T, initC=T, useCluster=T,
                      nbrNodes=12)

summary(ans.model3)
outTable(ans.model3)
saveRDS(ans.model3, file = "models/full.rds")

gof.id <- sienaGOF(ans.model3, verbose=TRUE, varName="net",
                   IndegreeDistribution, join=T, cumulative=F)
plot(gof.id)

gof.od <- sienaGOF(ans.model3, verbose=TRUE, varName="net",
                   OutdegreeDistribution, join=T, cumulative=F)
plot(gof.od)
```


### Preliminary GOF Tests

```{r}
gof.id <- sienaGOF(ans.model8, verbose=TRUE, varName="net",
                   IndegreeDistribution, join=T, cumulative=F)
plot(gof.id, violin=T)

gof.od <- sienaGOF(ans.model8, verbose=TRUE, varName="net",
                   OutdegreeDistribution, join=T, cumulative=F)
plot(gof.od)
```


### Wald tests

```{r}
Multipar.RSiena(ans.model1, c(8:10))
Multipar.RSiena(ans.model1, 8, 10)
Multipar.RSiena(ans.model1, 8, 9, 11, 12)

```

### Time Heterogeneity

```{r}
# TODO Check and what does it mean?
tt <- sienaTimeTest(ans.model1)

summary(tt)
plot(tt, pairwise=TRUE)
plot(tt)
```


# Others Models

## Restricted Model
  
```{r}
# Package-specific
effects <- setEffect(effects, altX, name="net", interaction1="depsUpVar",
                     include=T, test=T, fix=T)
effects <- setEffect(effects, altX, name="net", interaction1="depsDownVar",
                     include=T, test=T, fix=T)
effects <- setEffect(effects, altX, name="net", interaction1="comIntVar",
                     include=T, test=T, fix=T)
effects <- setEffect(effects, altX, name="net", interaction1="relActVar",
                     include=T, test=T, fix=T)
effects <- setEffect(effects, altX, name="net", interaction1="ageVar",
                     include=T, test=T, fix=T)

# Developer-specific
effects <- setEffect(effects, egoX, name="net", interaction1="devActVar",  # TODO Recalculate! 1 or 0 currently
                     include=T, test=T, fix=T)

ans.model1.stt <- siena07(algorithm, data=data, effects=effects,
                          batch=F, verbose=F, returnDeps=T, initC=T, useCluster=T,
                          nbrNodes=12)
saveRDS(ans.model1.stt, file = "models/model1_stt.rds")
```

```{r}
# Package-specific
effects <- setEffect(effects, altX, name="net", interaction1="depsUpVar",
                     include=T, test=F, fix=F)
effects <- setEffect(effects, altX, name="net", interaction1="depsDownVar",
                     include=T, test=F, fix=F)
effects <- setEffect(effects, altX, name="net", interaction1="comIntVar",
                     include=T, test=F, fix=F)
effects <- setEffect(effects, altX, name="net", interaction1="relActVar",
                     include=T, test=F, fix=F)
effects <- setEffect(effects, altX, name="net", interaction1="ageVar",
                     include=T, test=F, fix=F)

# Developer-specific
effects <- setEffect(effects, egoX, name="net", interaction1="devActVar",
                     include=T, test=F, fix=F)

ans.model1 <- siena07(algorithm, data=data, effects=effects,
                      batch=F, verbose=F, returnDeps=T, initC=T, useCluster=T,
                      nbrNodes=12)
outTable(ans.model1)
saveRDS(ans.model1, file = "models/model1.rds")
```

## Full Model

```{r}
effects <- setEffect(effects, inPopSqrt, name="net", include=T, test=T, fix=T)
effects <- setEffect(effects, outActSqrt, name="net", include=T, test=T, fix=T)
effects <- setEffect(effects, outInAss, name="net", include=T, test=T, fix=T)
effects <- setEffect(effects, cycle4, name="net", include=T, test=T, fix=T)
effects <- setEffect(effects, outRate, name="net", type="rate", include=T, test=T, fix=T)

ans.model2.stt <- siena07(algorithm, data=data, effects=effects,
                          batch=F, verbose=F, returnDeps=T, initC=T, useCluster=T,
                          nbrNodes=12)
summary(ans.model2.stt)
saveRDS(ans.model2.stt, file = "models/model2_stt.rds")
```

```{r}
effects <- setEffect(effects, inPopSqrt, name="net", include=T, test=F, fix=F)
effects <- setEffect(effects, outActSqrt, name="net", include=T, test=F, fix=F)
effects <- setEffect(effects, outInAss, name="net", include=F, test=F, fix=F)  # Excluded
effects <- setEffect(effects, cycle4, name="net", include=T, test=F, fix=F)
effects <- setEffect(effects, outRate, name="net", type="rate", include=T, test=F, fix=F)

ans.model2 <- siena07(algorithm, data=data, effects=effects,
                      batch=F, verbose=F, returnDeps=T, initC=T, useCluster=T,
                      nbrNodes=12)
outTable(ans.model2)
saveRDS(ans.model2, file = "models/model2.rds")
```

Full model performs bad! Check effects separately
- TODO: Add dyadic variables for up- and downstream dependencies

### Selection

```{r}
effects <- setEffect(effects, inPopSqrt, name="net", include=T, test=F, fix=F)
effects <- setEffect(effects, outActSqrt, name="net", include=F, test=F, fix=F)
effects <- setEffect(effects, outInAss, name="net", include=F, test=F, fix=F)  # Excluded
effects <- setEffect(effects, cycle4, name="net", include=F, test=F, fix=F)
effects <- setEffect(effects, outRate, name="net", type="rate", include=F, test=F, fix=F)

ans.model3 <- siena07(algorithm, data=data, effects=effects,
                      batch=F, verbose=F, returnDeps=T, initC=T, useCluster=T,
                      nbrNodes=12)
outTable(ans.model3)
saveRDS(ans.model3, file = "models/model3.rds")
```

```{r}
effects <- setEffect(effects, inPopSqrt, name="net", include=T, test=F, fix=F)
effects <- setEffect(effects, outActSqrt, name="net", include=T, test=F, fix=F)
effects <- setEffect(effects, outInAss, name="net", include=F, test=F, fix=F)  # Excluded
effects <- setEffect(effects, cycle4, name="net", include=F, test=F, fix=F)
effects <- setEffect(effects, outRate, name="net", type="rate", include=F, test=F, fix=F)

ans.model4 <- siena07(algorithm, data=data, effects=effects,
                      batch=F, verbose=F, returnDeps=T, initC=T, useCluster=T,
                      nbrNodes=12)
outTable(ans.model4)
saveRDS(ans.model4, file = "models/model4.rds")
```

# Goodness-of-Fit

```{r}
# Indegree Distributions
( gof.id.model0 <- sienaGOF(ans.model0, verbose=TRUE, varName="net",
                            IndegreeDistribution, join=T, cumulative=F) )
p1 <- plot(gof.id.model0)

( gof.id.model1 <- sienaGOF(ans.model1, verbose=TRUE, varName="net",
                            IndegreeDistribution, join=T, cumulative=F) )
p2 <- plot(gof.id.model1)

( gof.id.model2 <- sienaGOF(ans.model2, verbose=TRUE, varName="net",
                            IndegreeDistribution, join=T, cumulative=F) )
p3 <- plot(gof.id.model2)
```

```{r}
# Outdegree Distributions
( gof.od.model0 <- sienaGOF(ans.model0, verbose=TRUE, varName="net",
                            OutdegreeDistribution, join=T, cumulative=F) )
p4 <- plot(gof.od.model0)

( gof.od.model1 <- sienaGOF(ans.model1, verbose=TRUE, varName="net",
                            OutdegreeDistribution, join=T, cumulative=F) )
p5 <- plot(gof.od.model1)

( gof.od.model2 <- sienaGOF(ans.model2, verbose=TRUE, varName="net",
                            OutdegreeDistribution, join=T, cumulative=F) )
p6 <- plot(gof.od.model2)
```

```{r}
( gof.id.model3 <- sienaGOF(ans.model3, verbose=TRUE, varName="net",
                            IndegreeDistribution, join=T, cumulative=F) )

( gof.od.model3 <- sienaGOF(ans.model3, verbose=TRUE, varName="net",
                            OutdegreeDistribution, join=T, cumulative=F) )
```


# HICSS 2022 Script

```{r}
# SIENA Analysis using R for the Paper Submission to the 
#   Hawaii International Conference on System Sciences (HICSS) 2022.
# Written by Mario Mueller <mario.mueller@wiso.uni-koeln.de>
##############################################
# Contents:
#     (1) setup
#     (2) load & inspect data
#     (3) prepare objects for RSiena
#     (4) model specification & estimation
#     (5) goodness of fit
#     (6) time heterogeneity
#     (7) interpretation
#     (8) simulations
##############################################

# =======================================
# (1) setup
# =======================================

# Install the RSiena package
install.packages("RSiena")

# Load RSiena and sna
library(RSiena)
library(sna)

# Check RSiena version. The initial analysis run with version 1.2.23
packageVersion("RSiena")

# Required function for output and GOF analysis
# Functions are adapted from tutorial for the Social Networks and Health 
#   workshop at Duke University on May 18, 2018 by David R. Schaefer
outTable <- function(x) {
  coef <- abs(x$theta)
  coefPretty <- sprintf("%.3f", round(coef,3))
  se <- diag(x$covtheta)**.5
  sePretty <- sprintf("%.3f", round(se,3))
  pval <- 2*pnorm(-abs(coef/se))
  symp <- symnum(pval, corr = FALSE,
                 cutpoints = c(0,  .001,.01,.05, .1, 1),
                 symbols = c("***","**","*","."," "))
  convPretty <- sprintf("%.3f", round(abs(x$tconv),3))
  out1 <- noquote(cbind(
    Function = x$effects[[1]], 
    Effect = x$effects[[2]], 
    Coef = coefPretty, 
    StEr = sePretty, 
    Sig = symp, 
    Conv = convPretty))
  out2 <- paste("Maximum Convergence Ratio:", round(x$tconv.max,3))
  return(list(out1,out2))
}

# Functions required for GOF tests
GeodesicDistribution <- function (i, data, sims, period, groupName,
                                  varName, levls=c(1:5,Inf), cumulative=TRUE, ...) {
  x <- networkExtraction(i, data, sims, period, groupName, varName)
  require(sna)
  a <- sna::geodist(symmetrize(x))$gdist
  if (cumulative)
  {
    gdi <- sapply(levls, function(i){ sum(a<=i) })
  }
  else
  {
    gdi <- sapply(levls, function(i){ sum(a==i) })
  }
  names(gdi) <- as.character(levls)
  gdi
}

# Holland and Leinhardt Triad Census; see ?sna::triad.census.
TriadCensus <- function(i, data, sims, wave, groupName, varName, levls=1:16){
  unloadNamespace("igraph") # to avoid package clashes
  require(sna)
  require(network)
  x <- networkExtraction(i, data, sims, wave, groupName, varName)
  if (network.edgecount(x) <= 0){x <- symmetrize(x)}
  # because else triad.census(x) will lead to an error
  tc <- sna::triad.census(x)[1,levls]
  # names are transferred automatically
  tc
}


# =======================================
# (2) load & inspect data
# =======================================

# Set working directory
setwd('/Users/mariomueller/Workspace/posse/rsiena/')

# Load Data 
# 
# Adjacency Matrices of Dependency Network for each Observation
net1 <- as.matrix(read.table('data/net1.txt'))  # 2016
net2 <- as.matrix(read.table('data/net2.txt'))  # 2017
net3 <- as.matrix(read.table('data/net3.txt'))  # 2018
net4 <- as.matrix(read.table('data/net4.txt'))  # 2019

netList <- list(net1, net2, net3, net4)
netArray <- array(c(net1, net2, net3, net4), dim=c(dim(net1), length(netList)))

# Adjacency Matrices for Dependency Types for each Observation
# Note: The last observation is not considered for dyadic covariates
types1 <- as.matrix(read.table('data/net1-type.txt'))  # 2016
types2 <- as.matrix(read.table('data/net2-type.txt'))  # 2017
types3 <- as.matrix(read.table('data/net3-type.txt'))  # 2018

typesList <- list(types1, types2, types3)
typesArray <- array(c(types1, types2, types3), dim=c(dim(types1),
                    length(typesList)))

# Behavior Variable: Updates
updates <- as.matrix(read.table('data/updates-codes.txt'))

# Actor Variables
releases <- as.matrix(read.table('data/releases-codes.txt'))
licenses <- as.matrix(read.table('data/licenses-codes.txt'))
ages <- as.matrix(read.table('data/ages.txt'))

# Inspect Data
#
lapply(netList, dim)   # each network has the same number of actors as needed
lapply(netList, function(x) table(x, useNA='always'))

lapply(typesList, dim)   # each network has the same number of actors as needed
lapply(typesList, function(x) table(x, useNA='always'))

# Plot Network Changes
g.layout <- gplot(apply(netArray, c(1,2), max), usearrows=T)

par(mfrow=c(1,4))
for (i in 1:4) {
  gplot(netArray[,,i], arrowhead.cex=.75, edge.col='gray70', coord=g.layout, 	
        vertex.cex=1.5, main=paste('Dependency Network t',i,sep="") )
}

# =======================================
# (3) prepare objects for RSiena
# =======================================

netDep <- sienaDependent(netArray, type="oneMode")
updDep <- sienaDependent(updates, type="behavior")

typDyad <- varDyadCovar(typesArray)

licVar <- varCovar(licenses)
relVar <- varCovar(releases)
ageVar <- varCovar(ages)

changes <- sienaCompositionChangeFromFile('data/composition-changes.txt')

data <- sienaDataCreate(netDep, updDep, typDyad, licVar, relVar, ageVar, changes)

print01Report(data, modelname='hicss-2022')

# =======================================
# (4) model specification & estimation
# =======================================

algorithm <- sienaAlgorithmCreate(projname='hicss-2022')

effects <- getEffects(data)
effectsDocumentation(effects)

ans.model0 <- siena07(algorithm, data=data, effects=effects,
                      batch=F, verbose=F, returnDeps=T, initC=T, useCluster=T,
                      nbrNodes=4)

#------------------------
# Endogenous Effects
#------------------------

# Transitivity
effects <- includeEffects(effects, transTrip, name="netDep",
                          test=F, fix=F, include=T)
# Test interaction between reciprocity and transitivity (Block 2015)
effects <- includeEffects(effects, transRecTrip, name="netDep",
                          test=T, fix=T, include=T)
# Popularity
effects <- includeEffects(effects, inPop, name="netDep",
                          test=F, fix=F, include=T)
effects <- includeEffects(effects, outPop, name="netDep",
                          test=F, fix=F, include=T)
# Activity
effects <- includeEffects(effects, outAct, name="netDep",
                          test=F, fix=F, include=T)
# Assortativity
effects <- includeEffects(effects, outInAss, name="netDep",
                          test=F, fix=F, include=T)

eff.model0 <- effects
ans.model0 <- siena07(algorithm, data=data, effects=eff.model0,
                      batch=F, verbose=F, returnDeps=T, initC=T, useCluster=T,
                      nbrNodes=4)

outTable(ans.model0)

#------------------------
# Exogenous Effects
#------------------------
# Dependency Type
effects <- includeEffects(effects, WXX, name="netDep", interaction1="typDyad",
                          test=F, fix=F, include=T)
# License
effects <- includeEffects(effects, sameX, egoX, altX,
                          name="netDep", interaction1="licVar",
                          test=F, fix=F, include=T)
# Age
effects <- includeEffects(effects, simX, egoX, altX,
                          name="netDep", interaction1="ageVar",
                          test=F, fix=F, include=T)

eff.model1 <- effects
ans.model1 <- siena07(algorithm, data=data, effects=eff.model1,
                      batch=F, verbose=F, returnDeps=T, initC=T, useCluster=T,
                      nbrNodes=4)

outTable(ans.model1)

#------------------------
# Selection Effects
#------------------------
effects <- includeEffects(effects, altX, egoX, simX, name="netDep",
                          interaction1="updDep", test=F, fix=F, include=T)
eff.model2 <- effects
ans.model2 <- siena07(algorithm, data=data, effects=eff.model2,
                      batch=F, verbose=F, returnDeps=T, initC=T, useCluster=T,
                      nbrNodes=4)

outTable(ans.model2)

#------------------------
# Influence Effects
#------------------------
effects <- includeEffects(effects, outdeg, name="updDep", interaction1="netDep",
                          test=F, fix=F, include=T)
effects <- includeEffects(effects, indeg, name="updDep", interaction1="netDep",
                          test=F, fix=F, include=T)
effects <- includeEffects(effects, avSim, name="updDep", interaction1="netDep",
                          test=F, fix=F, include=T)

eff.model3 <- effects
ans.model3 <- siena07(algorithm, data=data, effects=eff.model3,
               batch=F, verbose=F, returnDeps=T, initC=T, useCluster=T,
               nbrNodes=4)

outTable(ans.model3)

# =======================================
# (5) Goodness-of-Fit Tests
# =======================================

# GOF for current estimates with comp changes
( gof.id <- sienaGOF(ans.model3, verbose=TRUE, varName="netDep",
                     IndegreeDistribution, join=T, cumulative=F) )
plot(gof.id)

( gof.od <- sienaGOF(ans.model3, verbose=TRUE, varName="netDep",
                     OutdegreeDistribution, join=T, cumulative=F) )
plot(gof.od)

( gof.gd <- sienaGOF(ans.model3, verbose=TRUE, varName="netDep",
                     GeodesicDistribution, join=T, cumulative=F) )
plot(gof.gd)

( gof.tc <- sienaGOF(ans.model3, verbose=TRUE, varName="netDep",
                     TriadCensus, join=T) )
plot(gof.tc, scale=TRUE, center=TRUE)

( gof.bd <- sienaGOF(ans.model3, verbose=TRUE, varName="updDep",
                     BehaviorDistribution, join=T) )
plot(gof.bd)

# =======================================
# (6) Time Heterogeneity
# =======================================

tt <- sienaTimeTest(ans)

summary(tt)
plot(tt)


# Save Workspace
save.image("hicss.RData")


###############################################################################
# Create new dataset without joiner and leavers,
# as advised in Ripley et al. (2021)
# Adjacency Matrices of Dependency Network for each Observation
net1GOF <- as.matrix(read.table('data/net1-gof.txt'))  # 2016
net2GOF <- as.matrix(read.table('data/net2-gof.txt'))  # 2017
net3GOF <- as.matrix(read.table('data/net3-gof.txt'))  # 2018
net4GOF <- as.matrix(read.table('data/net4-gof.txt'))  # 2019
netListGOF <- list(net1GOF, net2GOF, net3GOF, net4GOF)
netArrayGOF <- array(c(net1GOF, net2GOF, net3GOF, net4GOF),
                     dim=c(dim(net1GOF), length(netListGOF)))

types1GOF <- as.matrix(read.table('data/net1-type-gof.txt'))  # 2016
types2GOF <- as.matrix(read.table('data/net2-type-gof.txt'))  # 2017
types3GOF <- as.matrix(read.table('data/net3-type-gof.txt'))  # 2018
typesListGOF <- list(types1GOF, types2GOF, types3GOF)
typesArrayGOF <- array(c(types1GOF, types2GOF, types3GOF),
                       dim=c(dim(types1GOF), length(typesListGOF)))

netDepGOF <- sienaDependent(netArrayGOF, type="oneMode")
typDyadGOF <- varDyadCovar(typesArrayGOF)

dataGOF <- sienaDataCreate(netDepGOF, updDep, typDyadGOF, licVar, relVar, ageVar)

print01Report(dataGOF, modelname='hicss-2022-gof')

algorithmGOF <- sienaAlgorithmCreate(projname='hicss-2022-gof')

effectsGOF <- getEffects(dataGOF)

# Add effects of full model
effectsGOF <- includeEffects(effectsGOF, transTrip, inPop, outPop, outAct, 
                             name="netDepGOF")
effectsGOF <- includeEffects(effectsGOF, WXX, interaction1="typDyadGOF",
                             name="netDepGOF")
effectsGOF <- includeEffects(effectsGOF, altX, interaction1="updDep",
                             name="netDepGOF")
effectsGOF <- includeEffects(effectsGOF, sameX, interaction1="licVar",
                             name="netDepGOF")
effectsGOF <- includeEffects(effectsGOF, altX, interaction1="ageVar",
                             name="netDepGOF")
effectsGOF <- includeEffects(effectsGOF, simX, interaction1="ageVar",
                             name="netDepGOF")
effectsGOF <- includeEffects(effectsGOF, outdeg, interaction1="netDepGOF",
                             name="updDep")

ans.gof <- siena07(algorithmGOF, data=dataGOF, effects=effectsGOF,
                   batch=F, verbose=F, returnDeps=T, initC=T, useCluster=T,
                   nbrNodes=4)

( gof.id <- sienaGOF(ans.gof, verbose=TRUE, varName="netDepGOF",
                     IndegreeDistribution, join=T, cumulative=F) )
plot(gof.id)

( gof.od <- sienaGOF(ans.gof, verbose=TRUE, varName="netDepGOF",
                     OutdegreeDistribution, join=T, cumulative=F) )
plot(gof.od)

( gof.gd <- sienaGOF(ans.gof, verbose=TRUE, varName="netDepGOF",
                     GeodesicDistribution, join=T, cumulative=F) )
plot(gof.gd)

( gof.tc <- sienaGOF(ans.gof, verbose=TRUE, varName="netDepGOF",
                     TriadCensus, join=T) )
plot(gof.tc, scale=TRUE, center=TRUE)

( gof.bd <- sienaGOF(ans.gof, verbose=TRUE, varName="updDep",
                     BehaviorDistribution, join=T) )
plot(gof.bd)

```

